[{"id":0,"href":"/sbom-guide/reference/glossary/","title":"Glossary","section":"Reference","content":" Glossary # Notarize Notarize (definition) # "},{"id":1,"href":"/sbom-guide/vcn-usage/intro/","title":"Introduction to VCN","section":"Using vcn with Trustcenter","content":" Introduction to vcn # vcn is a command line tool that allows you to interact with Codenotary Trustcenter to notarize and authenticate your software assets. This documentation will guide you through the various ways you can use vcn to help manage the security of your software.\nSpecifying Assets in vcn Commands # Throughout this documentation, you\u0026rsquo;ll see the placeholder \u0026lt;artifact\u0026gt; used to refer to an asset that you want to authenticate or notarize. For example:\nvcn authenticate \u0026lt;artifact\u0026gt; The asset referred to by the \u0026lt;artifact\u0026gt; placeholder can be a file, directory, image, or git repository. The following are examples of how to specify an asset, where COMMAND is a placeholder for any vcn command that accepts an asset as an argument:\nvcn COMMAND \u0026lt;file\u0026gt; vcn COMMAND dir://\u0026lt;directory\u0026gt; vcn COMMAND image://\u0026lt;imageId\u0026gt; vcn COMMAND docker://\u0026lt;imageId\u0026gt; // deprecated, please use image vcn COMMAND podman://\u0026lt;imageId\u0026gt; vcn COMMAND git://\u0026lt;path_to_git_repo\u0026gt; vcn COMMAND --hash \u0026lt;hash\u0026gt; These docs will only use the \u0026lt;artifact\u0026gt; placeholder in examples, but the actual commands you run should specify the appropriate asset type based on one of the templates defined above.\nUsing the vcn CLI # To begin using the vcn CLI, you must first log in with your credentials for Codenotary Trustcenter. After you generate an API key in Trustcenter, you can log in with the vcn login command:\nvcn login --lc-host example.com If you are using vcn in a script, you can set the API key in the VCN_LC_API_KEY environment variable, and then run the vcn login command without the --lc-host flag:\nexport VCN_LC_API_KEY=\u0026lt;API_KEY\u0026gt; export VCN_LC_HOST=\u0026lt;TRUSTCENTER_DOMAIN\u0026gt; export VCN_LC_PORT=443 vcn login You can also specify the API key in an environment variable prefixed to the vcn login command.\nVCN_LC_API_KEY=\u0026lt;API_KEY\u0026gt; vcn login --lc-host \u0026lt;TRUSTCENTER_DOMAIN\u0026gt; However, by logging in without your API key present in the appropriate environment variable, the --signerID flag becomes mandatory.\n"},{"id":2,"href":"/sbom-guide/vcn-usage/notarizing-assets/","title":"Notarizing Assets","section":"Using vcn with Trustcenter","content":" Notarizing Assets # When using vcn with Codenotary Trustcenter, the notarization process creates a cryptographic signature of the asset and stores it in a cryptographically-verifiable immutable database (immudb). That signature can then be used to authenticate the asset and verify its integrity.\nNotarize an asset with vcn # The most basic way to notarize an asset is to pass the asset to the vcn notarize command:\nvcn notarize \u0026lt;artifact\u0026gt; This command will sign the combination of the asset\u0026rsquo;s name, version, and hash to unique identify it. vcn will then send the signature to Trustcenter, which will store an immutable record of the signature.\nNotarizing assets with dependencies # Passing the --bom flag to the vcn notarize command will notarize the asset itself, in combination with notarization the asset\u0026rsquo;s dependencies. This process will immutably associate the artifact with its dependencies in Trustcenter:\nvcn notarize --bom \u0026lt;artifact\u0026gt; Notarizing assets in bulk # If you need to notarize assets in bulk, you can supply a CSV file that enumerates the hash, name, and labels of each asset to the vcn notarize command:\nvcn notarize --import-file \u0026lt;csv_file\u0026gt; The contents of your CSV file should follow the format\nhash,name,labels where hash is the hash of the asset, name is the name of the asset, and labels is an optional list of semicolon-separated labels. For example, your CSV file will look something like this:\naddf340d683e7dc9be1859f4e9a85f5143d4b21c,libcrypto1.1@1.1.1q-r0,label1;label2 722a653f03c02836b5f6391bc588e28aff86e44b,libssl1.1@1.1.1q-r0,label2 2962576b068d3e220d1df7730a0fc5ac49a201a5,ssl_client@1.35.0-r17,label2;label3 124baa9bfd023f2c0308a11b13086c3c2c3ecfd1,zlib@1.2.12-r3,label1;label3 Add attachments to notarization transactions # To attach files containing user-defined supporting documentation (e.g., build pipeline metadata or deployment information) to a notarization transaction in Trustcenter, use the --attach flag to specify the path to the file and a label to identify it:\nvcn notarize \u0026lt;artifact\u0026gt; --attach=\u0026lt;ATTACHMENT_PATH\u0026gt;[:\u0026lt;ATTACHMENT_LABEL\u0026gt;] vcn notarize Flags Documentation --attach Add user defined file attachments. This flag can be repeated to include multiple attachments.\nIt\u0026rsquo;s possible to specify a label for each entry, by appending the label to the file path after a colon, for example: --attach=metadata.json:jobid123. When authenticating an asset with vcn authenticate, the same path and label can be specifed with the --attach flag to retrieve that attachment. The label alone can be specified with the --attach flag to retrieve all attachments, e.g. vcn a \u0026lt;artifact\u0026gt; --attach=jobid123.\n"},{"id":3,"href":"/sbom-guide/vcn-usage/authenticating-assets/","title":"Authenticating Assets","section":"Using vcn with Trustcenter","content":" Authenticating Assets with Trustcenter # After an asset has been notarized with Codenotary Trustcenter, it can be authenticated to verify the integrity and signature of the asset before deployment to a production environment.\nWhen an asset is authenticated, vcn will verify the integrity of the asset by comparing the hash of an asset with the signed hash stored by Trustcenter. If the hash of the asset matches the signed hash stored by Trustcenter and that asset is marked as Trusted, vcn will return a success message.\nUsing vcn to authenticate an asset # To authenticate an asset, which verifies the integrity of the asset by comparing it with the signed hash stored immutably by Trustcenter, use the vcn authenticate command:\nvcn authenticate \u0026lt;asset\u0026gt; vcn will query your immutable ledger in Trustcenter for a notarized record of the asset. If the record is found and the asset has been marked as Trusted, the asset has been authenticated and can be released to production.\nAuthenticate with a specific signerID with vcn # Using signerID:\nvcn authenticate --signerID \u0026lt;signerID\u0026gt; \u0026lt;asset\u0026gt; Authenticate multiple assets with vcn # To authenticate assets in batches, you can use xargs to call vcn authenticate on each asset in a directory:\nls | xargs vcn authenticate "},{"id":4,"href":"/sbom-guide/vcn-usage/labeling-assets/","title":"Labeling Assets","section":"Using vcn with Trustcenter","content":" Managing Assets with Labels # Codenotary Trustcenter can associate labels with your notarized artifacts to provide an additional level of metadata for authentication. Labels can be used to indicate the intended use of an artifact, such as production, staging, or development. Labels can also be used to indicate the type of artifact, such as library, binary, or container.\nLabels can be appended to, deleted from, or overwritten on an artifact when the vcn notarize command is run by passing the --labels-add, --labels-del, or --labels-set flags, as illustrated below.\nvcn Labeling Example # We can begin by notarizing an artifact with the --labels-add flag:\n❯ vcn n image://example --labels-add \u0026#39;label1,label2,label3\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . SignerID: demo-signer Apikey revoked: no Status: TRUSTED Labels: label1 (added), label2 (added), label3 (added) The asset can then be notarized again with the --labels-del flag to remove one of the labels from our signature for the artifact:\n❯ vcn notarize image://example --labels-del \u0026#39;label3\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label3 (removed) ❯ vcn inspect image://example --labels Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label1, label2 Then, after using the --labels-set flag to overwrite the existing labels on the artifact, we can use the --labels-add flag to append a final label to the artifact:\n❯ vcn notarize image://example --labels-set \u0026#39;label4,label5\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label4, label5 ❯ vcn notarize image://example --labels-add \u0026#39;label6\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label6 (added) ❯ vcn inspect image://example --labels Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label4, label5, label6 These labels provide an additional layer of metadata, and can be used to alter the results of the vcn authenticate command. For example, if we run the vcn authenticate command with the --label flag, the result will vary depending on the state of the asset\u0026rsquo;s labels:\nvcn inspect \u0026lt;artifact\u0026gt; --label \u0026#39;demo\u0026#39; How labels are used in authentication # If the artifact was marked Trusted, and the label demo is assigned, then the status is TRUSTED. the label demo is missing, then the status is UNKNOWN. If the artifact was marked Untrusted/Unsupported, and the label demo is assigned, then the status is UNTRUSTED/UNSUPPORTED (respectively). the label demo is missing, then the status is UNKNOWN. "},{"id":5,"href":"/sbom-guide/vcn-usage/bom-authentication/","title":"Authenticating SBOMs","section":"Using vcn with Trustcenter","content":" Notarizing and Authenticating Software Bills of Materials (SBOMs) with Trustcenter # When a Software Bill of Materials (SBOM) is notarized by vcn for a container image, codebase, or other build artifact, that asset\u0026rsquo;s entire manifest of dependencies is also notarized and they are immutably associated with one another.\nThis process creates a chain of custody for the asset and its dependencies, allowing you to check the integrity of the asset, track which artifacts are deployed on your infrastructure, and ensure untrusted dependencies never reach production.\nResolving dependencies with vcn # You can use the vcn bom command to collect and display an artifact\u0026rsquo;s manifest of dependencies:\nvcn bom \u0026lt;artifact\u0026gt; Example: vcn bom Example command:\nvcn bom image://python:3.10-alpine Output:\n:\talpine-baselayout-data@3.2.0-r22 :\tmusl@1.2.3-r0 :\tbusybox@1.35.0-r17 :\talpine-baselayout@3.2.0-r22 :\talpine-keys@2.4-r1 :\tca-certificates-bundle@20220614-r0 :\tlibcrypto1.1@1.1.1q-r0 :\tlibssl1.1@1.1.1q-r0 :\tssl_client@1.35.0-r17 :\tzlib@1.2.12-r3 :\tapk-tools@2.12.9-r3 :\tscanelf@1.3.4-r0 :\tmusl-utils@1.2.3-r0 :\tlibc-utils@0.7.2-r3 :\tca-certificates@20220614-r0 :\ttzdata@2022a-r0 :\tncurses-terminfo-base@6.3_p20220521-r0 :\tncurses-libs@6.3_p20220521-r0 :\tlibbz2@1.0.8-r1 :\tsqlite-libs@3.38.5-r0 :\tlibffi@3.4.2-r1 :\tgdbm@1.23-r0 :\txz-libs@5.2.5-r1 :\texpat@2.4.8-r0 :\tlibintl@0.21-r2 :\tlibtirpc-conf@1.3.2-r1 :\tkrb5-conf@1.0-r2 :\tlibcom_err@1.46.5-r0 :\tkeyutils-libs@1.6.3-r1 :\tlibverto@0.3.2-r0 :\tkrb5-libs@1.19.3-r0 :\tlibtirpc@1.3.2-r1 :\tlibnsl@2.0.0-r0 :\tlibuuid@2.38-r1 :\treadline@8.1.2-r0 :\t.python-rundeps@20220907.224335 Notarizing an artifact\u0026rsquo;s bill of materials # You can make use of a bill of materials by notarizing it together with the artifact, using the vcn notarize command and the --bom flag:\nvcn notarize --bom \u0026lt;artifact\u0026gt; # Short form of command: vcn n --bom \u0026lt;artifact\u0026gt; Authenticating an artifact\u0026rsquo;s bill of materials # After an artifact has been notarized with its bill of materials, you can authenticate the artifact and its dependencies, using the vcn authenticate command and the --bom flag:\nvcn authenticate --bom \u0026lt;artifact\u0026gt; # Short form of command: vcn a --bom \u0026lt;artifact\u0026gt; "},{"id":6,"href":"/sbom-guide/vcn-usage/managing-dependencies/","title":"Working with Dependencies","section":"Using vcn with Trustcenter","content":" Looking up known dependencies with vcn # To\nvcn a --bom-what-includes (\u0026lt;scheme\u0026gt;://\u0026lt;name\u0026gt;@\u0026lt;version\u0026gt; | --hash \u0026lt;hash\u0026gt;) Container support with vcn # To\nvcn \u0026lt;command\u0026gt; \u0026lt;scheme\u0026gt;://\u0026lt;image_or_container\u0026gt; [command options] Cascade operations with vcn # To\nvcn notarize|untrust|unsupport [command options ...] --bom-cascade [--bom-force] "},{"id":7,"href":"/sbom-guide/vcn-usage/dependency-authentication/","title":"Authenticating Dependencies","section":"Using vcn with Trustcenter","content":" Authenticating Trusted Dependencies # If we attempt to authenticate a Docker image which has not yet been notarized with our signing key, we receive a warning that the asset hasn\u0026rsquo;t yet been notarized:\n❯ vcn authenticate --bom docker://python:3.9-alpine Warning: c9b90024bc4d49b1fa0ea4673b6eb1db1058cd1cba4b840d336bedf803a0afcf was not notarized When we then notarize the image, all of its dependencies are resolved, authenticated with Trustcenter, signed, and marked as Trusted:\n❯ vcn notarize --bom image://python:3.9-alpine Your assets will not be uploaded. They will be processed locally. Notarization in progress... artifact notarized Kind: image Name: python:3.9-alpine Hash: dca341b7a3fdbe1aa117f97f55321e60fe54a177d6f58ab3373ece796aca52ef Metadata: hashtype=\u0026#34;SHA256\u0026#34; image={ \u0026#34;Architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-07 23:29:27.440739972 +0000 UTC\u0026#34;, \u0026#34;DockerVersion\u0026#34;: \u0026#34;20.10.12\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;0721d3b351f08b8a337ace23d9e1f99cc9cab25b3459b95359b85054c631a1af\u0026#34;, . . . } platform=\u0026#34;linux\u0026#34; architecture=\u0026#34;amd64\u0026#34; SignerID: demo-signer Apikey revoked: no Status: TRUSTED Dependencies: busybox@1.35.0-r17 899f82d8925d0659b628ab403a44a433bcd97a06 TRUSTED musl@1.2.3-r0 682bb42e6503a00152397e3db87be4602d566ac4 TRUSTED alpine-keys@2.4-r1 1417c88edb049afbaaa0d5e94a15c3726fe68f31 TRUSTED alpine-baselayout@3.2.0-r22 97afe73342be73255da8d7e0929d7f73a625ce4d TRUSTED . . . keyutils-libs@1.6.3-r1 19eb523e1d62d8b90431763aa3073d30e3283fb2 TRUSTED libuuid@2.38-r1 68bd5e9b8fe99566387e2ad7b7a44c8cf0936673 TRUSTED readline@8.1.2-r0 f676007339535e21de79acffbe7ae743a1f7168c TRUSTED .python-rundeps@20220907.232918 2d6f839e7b5f86c10811f4574f044b3b3ad53417 TRUSTED If we then attempt to authenticate the image we just notarized, we can confirm that it is now marked as Trusted:\nvcn authenticate --bom image://python:3.9-alpine Kind: image Name: python:3.9-alpine Hash: dca341b7a3fdbe1aa117f97f55321e60fe54a177d6f58ab3373ece796aca52ef Metadata: architecture=\u0026#34;amd64\u0026#34; hashtype=\u0026#34;SHA256\u0026#34; image={ \u0026#34;Architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-07 23:29:27.440739972 +0000 UTC\u0026#34;, \u0026#34;DockerVersion\u0026#34;: \u0026#34;20.10.12\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;0721d3b351f08b8a337ace23d9e1f99cc9cab25b3459b95359b85054c631a1af\u0026#34;, . . . } platform=\u0026#34;linux\u0026#34; SignerID: demo-signer Apikey revoked: no Status: TRUSTED Dependencies: alpine-baselayout-data@3.2.0-r22 bf84212e37b7916942f03263f997c94e39494525 TRUSTED musl@1.2.3-r0 682bb42e6503a00152397e3db87be4602d566ac4 TRUSTED busybox@1.35.0-r17 899f82d8925d0659b628ab403a44a433bcd97a06 TRUSTED alpine-baselayout@3.2.0-r22 97afe73342be73255da8d7e0929d7f73a625ce4d TRUSTED . . . keyutils-libs@1.6.3-r1 19eb523e1d62d8b90431763aa3073d30e3283fb2 TRUSTED libuuid@2.38-r1 68bd5e9b8fe99566387e2ad7b7a44c8cf0936673 TRUSTED readline@8.1.2-r0 f676007339535e21de79acffbe7ae743a1f7168c TRUSTED .python-rundeps@20220907.232918 2d6f839e7b5f86c10811f4574f044b3b3ad53417 TRUSTED Let\u0026rsquo;s say there is a hypothetical vulnerability discovered in the package keyutils-libs@1.6.3-r1, and we want to ensure we don\u0026rsquo;t run any containers based on images containing this dependency.\nWe can take the untrusted dependency\u0026rsquo;s hash and mark it as untrusted:\n❯ vcn untrust --hash 19eb523e1d62d8b90431763aa3073d30e3283fb2 Your assets will not be uploaded. They will be processed locally. Notarization in progress... artifact notarized Name: keyutils-libs Hash: 19eb523e1d62d8b90431763aa3073d30e3283fb2 Metadata: hashtype=\u0026#34;SHA1\u0026#34; license=\u0026#34;GPL-2.0-or-later LGPL-2.0-or-later\u0026#34; version=\u0026#34;1.6.3-r1\u0026#34; SignerID: demo-signer Apikey revoked: no Status: UNTRUSTED Now, when we attempt to notarize any assets that contain our known-vulnerable dependency, we will see that the notarization fails:\n❯ vcn notarize --bom image://python:3.10-alpine Dependency keyutils-libs@1.6.3-r1 trust level is UNTRUSTED Error: some dependencies have insufficient trust level so artifact cannot be notarized. You can override it with --bom-force option Because the keyutils-libs@1.6.3-r1 dependency has already been marked as untrusted with our current signing key, any future attempts to notarize an asset containing that dependency will fail.\n"},{"id":8,"href":"/sbom-guide/vcn-usage/bom-interoperability/","title":"Working with Other Tools","section":"Using vcn with Trustcenter","content":" Exchanging Data with Other Tools # Import from spfx and cyclonedx # TODO.\nExport to spfx or cyclonedx # TODO.\n"},{"id":9,"href":"/sbom-guide/reference/glossary/notarize/","title":"Notarize","section":"Glossary","content":" Notarize (definition) # "},{"id":10,"href":"/sbom-guide/examples/vulnerability-search/","title":"Searching for Vulnerabilities","section":"Examples \u0026 Use Cases","content":" Searching for Vulnerabilities with Trustcenter # "}]