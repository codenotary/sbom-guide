[{"id":0,"href":"/sbom-guide/sbom-intro/sbom-intro/","title":"Introduction","section":"Understanding SBOMs","content":" Introduction to Software Bills of Materials (SBOMs) # A Software Bill of Materials (SBOM) is a manifest which uniquely identifies and enumerates the software dependencies contained within a codebase, build artifact, or runtime container. A dynamic SBOM can further integrate information from vulnerability scanners to help ensure the integrity of your software supply chain.\nWhat is motivating the need for SBOMs? # To quote President Biden\u0026rsquo;s Executive Order 14028 on Improving the Nation’s Cybersecurity:\n[T]he trust we place in our digital infrastructure should be proportional to how trustworthy and transparent that infrastructure is, and to the consequences we will incur if that trust is misplaced.\nThis order calls for transparency in the software supply chain, and SBOMs are a key part of that transparency. Notably, the policies laid out in this order will require vendors to provide SBOMs for all software they sell to the federal government, which will result in more vendors requesting SBOMs from their upstream suppliers.\nThe tooling and standards for SBOMs are continuing to mature, and as it becomes increasingly important for developers of both proprietary and open source software to generate SBOMs for their projects, the integration of SBOMs into software development workflows will become more widespread. A pilot program created by the above order shows the potential for how SBOMs can be used to communicate the security posture of software products (emphasis added):\n[The executive order] creates a pilot program to create an “energy star” type of label so the government – and the public at large – can quickly determine whether software was developed securely. Too much of our software, including critical software, is shipped with significant vulnerabilities that our adversaries exploit. This is a long-standing, well-known problem, but for too long we have kicked the can down the road. We need to use the purchasing power of the Federal Government to drive the market to build security into all software from the ground up.\nWhat is contained in a Software Bill of Materials? # Generally speaking, an SBOM is a nested inventory of uniquely-identified dependencies.\nFrom the NTIA\u0026rsquo;s SBOM FAQ (pdf) answer about what should be included in an SBOM:\nAn SBOM should contain some combination of the following baseline information: author name, supplier name, component name, version string, component hash, unique identifier, and relationship. Licensing, pedigree, provenance, should also be included, if available.\nWhen an SBOM is generated by a tool such as Codenotary\u0026rsquo;s cas CLI, the complete inventory of included software components is generated locally—using the dependency trees assembled by build tools and package managers.\nAssembled SBOMs can be shared between projects through interchange formats such as SPDX. That specification provides a common data format for sharing information about the provenance, licenses, and security information associated with a given component.\nOther variants of SBOMs have appeared alongside the full SPDX specification, such as SPDX Lite, a subset of the full specification, and CycloneDX, a lightweight standard designed for application security contexts.\nHow is it used? # Because an SBOM is fundamentally a metadata file meant to inventory components in use, a straightforward use case for these manifests is in determining what software is running where. When new vulnerabilities emerge (e.g. the log4j vulnerability), an inventory of all software components running on your infrastructure enables removal of these threats. When an SBOM is included in a dynamic, searchable SBOM database, developers can quickly find specific dependencies within their production assets.\nFrom a security perspective, SBOMs increase transparency of the software supply chain and allow projects to avoid including dependencies with known vulnerabilities. When build artifacts are scanned for components with known vulnerabilities while in the build pipeline—long before the those vulnerabilities ever reach your production environment—the risk of releasing known-dangerous components is reduced.\nWhen using CAS, notarized assets can be marked as Unsupported, and you configure the cas CLI to exit with an error when those unsupported dependencies are encountered. In addition to the security benefits of notarized SBOMs, uniquely-identified assets being marked as Unsupported helps keep outdated components from being deployed.\nEnriched SBOMs like those from Codenotary Trustcenter track metadata about runtime environments (in addition to component dependencies), such as which Docker images contain a given dependency, providing additional visibility into deployments.\n"},{"id":1,"href":"/sbom-guide/sbom-intro/sbom-concepts/","title":"SBOM Concepts","section":"Understanding SBOMs","content":" SBOM Concepts # Improving Transparency # When the dependencies of a software asset are enumerated in an SBOM, it becomes possible to track where artifacts are deployed when new vulnerabilities are discovered. This is especially useful when the SBOM is stored in a searchable database (such as Codenotary Trustcenter).\nA software bill of materials is an important part of software supply chain security, because it surfaces the various artifacts that are bundled with a given software asset and enables developers to quickly identify and remove vulnerable components.\nBeyond the security applications of SBOMs, they also play a role in licensing and regulatory compliance. For example, the Software Package Data Exchange (SPDX) is a major standard SBOM format which communicates \u0026ldquo;the components, licenses, and copyrights associated with a software package,\u0026rdquo; and most developers have probably already encountered SPDX license identifiers in their projects (e.g. MIT or GPL-3.0-or-later).\nTaking an Inventory of Software Dependencies # Ideally, every software project and build artifact would come with an SBOM attached. While that may not always be feasible, any developer can create an SBOM for their project which enumerates the dependencies of their project—and defines the relationship between those dependencies and the project.\nDependency Relationships\nFrom Software Bill of Materials Elements and Considerations by the National Telecommunications and Information Administration, US Department of Commerce:\n[T]he “dependency relationship” generally refers to the idea that one component is included in another component, but could be expanded to also include referencing standards, which tools were used, or how software was compiled or built. [\u0026hellip;] As one SBOM document notes, “[c]omponent identification is fundamental to SBOM and needs to scale globally across diverse software ecosystems, sectors, and markets.” Documenting the Software Supply Chain # Although the relationship between a project and its dependencies generally refers to which components are included in a piece of software, the relationships between two components in an SBOM can be defined in any number of ways that describe various points in the creation of an artifact.\nFor example, the SPDX specification not only provides a mechanism for defining relations such as DEPENDS_ON and RUNTIME_DEPENDENCY_OF, but also allows for defining relationships with the DOCUMENTATION_OF a project or the BUILD_TOOL_OF of a given build artifact.\nEnumerating Dependencies # Tools such as Syft and CodeNotary\u0026rsquo;s cas CLI can scan container images and codebases for libraries and other dependencies included within. When the SBOMs generated by these tools are shared with downstream consumers of a software project, they can be included in the SBOM for that project to track the provenance of each component in the entire dependency tree.\nStructuring SBOMs # A software bill of materials is typically structured according to an interchange format for SBOMs, such as SPDX or CycloneDX. The information architecture of an SBOM varies depending on the tool that is used to generate it, as well as the purpose of the SBOM and the needs of downstream consumers, but the basic set of properties is generally consistent between formats.\nBaseline Component Information\nThe \u0026ldquo;baseline component information\u0026rdquo; of an SBOM, according to Software Bill of Materials Elements and Considerations by the NTIA:\nSupplier name Component name Version of the component Cryptographic hash of the component Any other unique identifier Dependency relationship Author of the SBOM data An SBOM should include information that uniquely associates it with the software artifact it describes, typically the name and version identifier of the asset, along with a cryptographic hash of the files that constitute the asset. Beyond that, to be used in any sort of meaningful way, an SBOM should include information about the relationship between the asset and its dependencies.\n"},{"id":2,"href":"/sbom-guide/sbom-intro/spdx-documents/","title":"SPDX Documents","section":"Understanding SBOMs","content":" Documenting Software Artifacts with SBOMs # The Software Package Data Exchange (SPDX) Specification is an open standard for communicating software bill of materials (SBOM) information.\nSPDX is an initiative of the Linux Foundation created to develop tools and formats for communicating the licensing information of software packages. Most developers have probably already encountered one specification from SPDX in the form of the SPDX License List, which is \u0026ldquo;a list of commonly found licenses and exceptions used for open source and other collaborative software.\u0026rdquo; If you\u0026rsquo;ve defined a license in a Node project\u0026rsquo;s package.json file or a Python project\u0026rsquo;s pyproject.toml file, you\u0026rsquo;ve already interacted with a core component of an SPDX SBOM.\nThe Software Package Data Exchange (SPDX) Specification defines a data exchange format for information about software packages and related content, \u0026ldquo;collected and shared in a common format with the goal of saving time and improving data accuracy.\u0026rdquo;\nSPDX Document Examples\nThe examples in this section are taken from the SPDX YAML Example, v2.2.2. The content presented in some of the examples below has been modified or reformatted as necessary for the purposes of this guide. For full examples in each of the available formats for SPDX documents, have a look at Producing/Consuming SPDX Documents on the SPDX website.\nContent omitted for formatting or clarity may be replaced with an ellipsis (. . .).\nSPDX for Licensing Compliance # Let\u0026rsquo;s have a look at how SPDX enables licensing compliance, as a demonstration of the practical applications of SBOMs.\nThe only mandatory section of an SPDX document is the metadata for the document itself, where the document creator can define the SPDX Specification Version, a data license for the information contained in the SBOM document itself (always CC0-1.0, to ensure SBOM metadata can be freely used), the SPDX Identifier that references the document itself, and several other attributes that explain how the SPDX document was created.\nDefining a Software Package # In the additional sections of an SPDX document, the licensing relationships between a software project and its dependencies are defined in a structured way. When an SPDX document is describing a software package, it first defines the metadata of the package that the document describes, including the package\u0026rsquo;s name, version, supplier, the URI of the document\u0026rsquo;s source project, and checksums for the package\u0026rsquo;s distributed file.\npackages: - SPDXID: \u0026#34;SPDXRef-Package\u0026#34; name: \u0026#34;glibc\u0026#34; originator: \u0026#34;Organization: ExampleCodeInspect (contact@example.com)\u0026#34; packageFileName: \u0026#34;glibc-2.11.1.tar.gz\u0026#34; packageVerificationCode: packageVerificationCodeExcludedFiles: - \u0026#34;./package.spdx\u0026#34; packageVerificationCodeValue: \u0026#34;d6a770ba38583ed4bb4525bd96e50461655d2758\u0026#34; sourceInfo: \u0026#34;uses glibc-2_11-branch from git://sourceware.org/git/glibc.git.\u0026#34; summary: \u0026#34;GNU C library.\u0026#34; supplier: \u0026#34;Person: Jane Doe (jane.doe@example.com)\u0026#34; versionInfo: \u0026#34;2.11.1\u0026#34; checksums: - algorithm: \u0026#34;MD5\u0026#34; checksumValue: \u0026#34;624c1abb3664f4b35547e7c73864ad24\u0026#34; - algorithm: \u0026#34;SHA1\u0026#34; checksumValue: \u0026#34;85ed0817af83a24ad8da68c2b5094de69833983c\u0026#34; - algorithm: \u0026#34;SHA256\u0026#34; checksumValue: \u0026#34;11b6d3ee554eedf79299905a98f9b9a04e498210b59f15094c916c91d150efcd\u0026#34; downloadLocation: \u0026#34;http://ftp.gnu.org/gnu/glibc/glibc-ports-2.15.tar.gz\u0026#34; Defining a Package\u0026rsquo;s License # For defining the license of a software package and its relationship with the package\u0026rsquo;s dependencies, SPDX provides several different properties for communicating any licensing information surfaced by a license scanner application. At the highest level, where the package\u0026rsquo;s actual licensing information is defined, an SPDX document may incorporate information extracted directly from the package, any copyright and licensing information found from scanning the source code, and any conclusions that the document creator (such as a license scanning tool) has made about how the licenses defined in the package apply:\npackages: - SPDXID: \u0026#34;SPDXRef-Package\u0026#34; . . . attributionTexts: - \u0026#34;The GNU C Library is free software. See the file COPYING.LIB for copying conditions,\\ \\ and LICENSES for notices about a few contributions that require these additional\\ \\ notices to be distributed. License copyright years may be listed using range\\ \\ notation, e.g., 1996-2015, indicating that every year in the range, inclusive,\\ \\ is a copyrightable year that would otherwise be listed individually.\u0026#34; copyrightText: \u0026#34;Copyright 2008-2010 John Smith\u0026#34; filesAnalyzed: true licenseConcluded: \u0026#34;(LGPL-2.0-only OR LicenseRef-3)\u0026#34; licenseDeclared: \u0026#34;(LGPL-2.0-only AND LicenseRef-3)\u0026#34; licenseInfoFromFiles: - \u0026#34;GPL-2.0-only\u0026#34; - \u0026#34;LicenseRef-2\u0026#34; - \u0026#34;LicenseRef-1\u0026#34; licenseComments: \u0026#34;The license for this project changed with the release of version\\ \\ x.y. The version of the project included here post-dates the license change.\u0026#34; The metadata defining how an SPDX document\u0026rsquo;s contents were generated allows for downstream consumers of an SBOM to determine how the included information meets their particular needs. This information is critical for ensuring that the SBOM is accurate and complete; for example, if a package scanner only returns the license declared for a package itself (without scanning the source code to determine if other licenses apply), it may not meet the needs of an organization that incorporates components from many different open source projects into its own products.\nDefining the Constituents of a Package # When a license scanner produces an SPDX document for a software project, if it detects licensing information for some code buried deep inside the project, it may surface this information in a dedicated \u0026ldquo; other licensing information detected\u0026rdquo; section.\nhasExtractedLicensingInfos: - licenseId: \u0026#34;LicenseRef-1\u0026#34; extractedText: \u0026#34;/*\\n * (c) Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\\ \\ 2008, 2009 Hewlett-Packard Development Company, LP\\n * All rights reserved.\\n\\ \\ *\\n * Redistribution and use in source and binary forms, with or without\\n *\\ \\ modification, are permitted provided that the following conditions\\n * are met:\\n\\ \\ * 1. Redistributions of source code must retain the above copyright\\n * notice,\\ . . . */\u0026#34; - licenseId: \u0026#34;LicenseRef-2\u0026#34; extractedText: \u0026#34;This package includes the GRDDL parser developed by Hewlett Packard\\ \\ under the following license:\\n� Copyright 2007 Hewlett-Packard Development Company,\\ \\ LP\\n\\nRedistribution and use in source and binary forms, with or without modification,\\ \\ are permitted provided that the following conditions are met: \\n\\nRedistributions\\ . . . \u0026#34; - licenseId: \u0026#34;LicenseRef-4\u0026#34; extractedText: \u0026#34;/*\\n * (c) Copyright 2009 University of Bristol\\n * All rights reserved.\\n\\ \\ *\\n * Redistribution and use in source and binary forms, with or without\\n *\\ . . . */\u0026#34; - licenseId: \u0026#34;LicenseRef-Beerware-4.2\u0026#34; comment: \u0026#34;The beerware license has a couple of other standard variants.\u0026#34; extractedText: \u0026#34;\\\u0026#34;THE BEER-WARE LICENSE\\\u0026#34; (Revision 42):\\nphk@FreeBSD.ORG wrote\\ \\ this file. As long as you retain this notice you\\ncan do whatever you want with\\ \\ this stuff. If we meet some day, and you think this stuff is worth it, you can\\ \\ buy me a beer in return Poul-Henning Kamp\u0026#34; name: \u0026#34;Beer-Ware License (Version 42)\u0026#34; seeAlsos: - \u0026#34;http://people.freebsd.org/~phk/\u0026#34; - licenseId: \u0026#34;LicenseRef-3\u0026#34; comment: \u0026#34;This is tye CyperNeko License\u0026#34; extractedText: \u0026#34;The CyberNeko Software License, Version 1.0\\n\\n \\n(C) Copyright\\ \\ 2002-2005, Andy Clark. All rights reserved.\\n \\nRedistribution and use in source\\ \\ and binary forms, with or without\\nmodification, are permitted provided that\\ . . . \u0026#34; name: \u0026#34;CyberNeko License\u0026#34; seeAlsos: - \u0026#34;http://people.apache.org/~andyc/neko/LICENSE\u0026#34; - \u0026#34;http://justasample.url.com\u0026#34; The licensing information from this SBOM comprises three different proprietary licenses and a common open source licens with several known variants. The license scanner has found licenses attached to specific pieces of source code within the project, and in this particular example, compliance with those licenses is achieved by retaining the original copyright and license information in each of source files.\nWhen the licenses found within a project impose restrictions on using the code, the \u0026ldquo;other licensing information detected\u0026rdquo; section of the SBOM provides downstream consumers with an understanding of what those restrictions entail. For example, if a project incorporates and modifies large pieces of code from projects that are licensed as GPL-2.0-only and GPL-2.0-or-later, licensing those modifications as GPL-3.0-or-later would not be compliant with the original license of some of the code.\nWhy does this matter? # As this example demonstrates, fully understanding the licensing of a software artifact and its dependencies is necessary to have any idea if you are complying with those terms.\nLikewise, if you want to ensure dependencies with known vulnerabilities are not included in your projects, you need to have a full picture of the components comprising your software. This brings us to the security applications of SBOMs\u0026hellip;\n"},{"id":3,"href":"/sbom-guide/sbom-intro/supply-chain/","title":"Software Security","section":"Understanding SBOMs","content":" Increasing the Security of Software # Definitions # Notarization or Signing is the process of creating a cryptographic signature of a software asset and, optionally, storing it in a cryptographically-verifiable immutable ledger. The signature can then be used to verify the integrity of the asset and authenticate its chain of custody.\nAuthentication is the process of verifying the integrity of a software asset by comparing its unique hash with a hash signed by a known trusted signer identity. Authentication is critical for tracking the provenance of software assets and ensuring that they have not been tampered with.\n"},{"id":4,"href":"/sbom-guide/reference/glossary/","title":"Glossary","section":"Reference","content":" Glossary # Notarize Notarize (definition) # "},{"id":5,"href":"/sbom-guide/vcn-usage/intro/","title":"Introduction to VCN","section":"Using vcn with Trustcenter","content":" Introduction to vcn # vcn is a command line tool that allows you to interact with Codenotary Trustcenter to notarize and authenticate your software assets. This documentation will guide you through the various ways you can use vcn to help manage the security of your software.\nSpecifying Assets in vcn Commands # Throughout this documentation, you\u0026rsquo;ll see the placeholder \u0026lt;artifact\u0026gt; used to refer to an asset that you want to authenticate or notarize. For example:\nvcn authenticate \u0026lt;artifact\u0026gt; The asset referred to by the \u0026lt;artifact\u0026gt; placeholder can be a file, directory, image, or git repository. The following are examples of how to specify an asset, where COMMAND is a placeholder for any vcn command that accepts an asset as an argument:\nvcn COMMAND \u0026lt;file\u0026gt; vcn COMMAND dir://\u0026lt;directory\u0026gt; vcn COMMAND image://\u0026lt;imageId\u0026gt; vcn COMMAND docker://\u0026lt;imageId\u0026gt; // deprecated, please use image vcn COMMAND podman://\u0026lt;imageId\u0026gt; vcn COMMAND git://\u0026lt;path_to_git_repo\u0026gt; vcn COMMAND --hash \u0026lt;hash\u0026gt; These docs will only use the \u0026lt;artifact\u0026gt; placeholder in examples, but the actual commands you run should specify the appropriate asset type based on one of the templates defined above.\nUsing the vcn CLI # To begin using the vcn CLI, you must first log in with your credentials for Codenotary Trustcenter. After you generate an API key in Trustcenter, you can log in with the vcn login command:\nvcn login --lc-host example.com If you are using vcn in a script, you can set the API key in the VCN_LC_API_KEY environment variable, and then run the vcn login command without the --lc-host flag:\nexport VCN_LC_API_KEY=\u0026lt;API_KEY\u0026gt; export VCN_LC_HOST=\u0026lt;TRUSTCENTER_DOMAIN\u0026gt; export VCN_LC_PORT=443 vcn login You can also specify the API key in an environment variable prefixed to the vcn login command.\nVCN_LC_API_KEY=\u0026lt;API_KEY\u0026gt; vcn login --lc-host \u0026lt;TRUSTCENTER_DOMAIN\u0026gt; However, by logging in without your API key present in the appropriate environment variable, the --signerID flag becomes mandatory.\n"},{"id":6,"href":"/sbom-guide/vcn-usage/notarizing-assets/","title":"Notarizing Assets","section":"Using vcn with Trustcenter","content":" Notarizing Assets # When using vcn with Codenotary Trustcenter, the notarization process creates a cryptographic signature of the asset and stores it in a cryptographically-verifiable immutable database (immudb). That signature can then be used to authenticate the asset and verify its integrity.\nNotarize an asset with vcn # The most basic way to notarize an asset is to pass the asset to the vcn notarize command:\nvcn notarize \u0026lt;artifact\u0026gt; This command will sign the combination of the asset\u0026rsquo;s name, version, and hash to unique identify it. vcn will then send the signature to Trustcenter, which will store an immutable record of the signature.\nNotarizing assets with dependencies # Passing the --bom flag to the vcn notarize command will notarize the asset itself, in combination with notarization the asset\u0026rsquo;s dependencies. This process will immutably associate the artifact with its dependencies in Trustcenter:\nvcn notarize --bom \u0026lt;artifact\u0026gt; Notarizing assets in bulk # If you need to notarize assets in bulk, you can supply a CSV file that enumerates the hash, name, and labels of each asset to the vcn notarize command:\nvcn notarize --import-file \u0026lt;csv_file\u0026gt; The contents of your CSV file should follow the format\nhash,name,labels where hash is the hash of the asset, name is the name of the asset, and labels is an optional list of semicolon-separated labels. For example, your CSV file will look something like this:\naddf340d683e7dc9be1859f4e9a85f5143d4b21c,libcrypto1.1@1.1.1q-r0,label1;label2 722a653f03c02836b5f6391bc588e28aff86e44b,libssl1.1@1.1.1q-r0,label2 2962576b068d3e220d1df7730a0fc5ac49a201a5,ssl_client@1.35.0-r17,label2;label3 124baa9bfd023f2c0308a11b13086c3c2c3ecfd1,zlib@1.2.12-r3,label1;label3 Add attachments to notarization transactions # To attach files containing user-defined supporting documentation (e.g., build pipeline metadata or deployment information) to a notarization transaction in Trustcenter, use the --attach flag to specify the path to the file and a label to identify it:\nvcn notarize \u0026lt;artifact\u0026gt; --attach=\u0026lt;ATTACHMENT_PATH\u0026gt;[:\u0026lt;ATTACHMENT_LABEL\u0026gt;] vcn notarize Flags Documentation --attach Add user defined file attachments. This flag can be repeated to include multiple attachments.\nIt\u0026rsquo;s possible to specify a label for each entry, by appending the label to the file path after a colon, for example: --attach=metadata.json:jobid123. When authenticating an asset with vcn authenticate, the same path and label can be specifed with the --attach flag to retrieve that attachment. The label alone can be specified with the --attach flag to retrieve all attachments, e.g. vcn a \u0026lt;artifact\u0026gt; --attach=jobid123.\n"},{"id":7,"href":"/sbom-guide/vcn-usage/authenticating-assets/","title":"Authenticating Assets","section":"Using vcn with Trustcenter","content":" Authenticating Assets with Trustcenter # After an asset has been notarized with Codenotary Trustcenter, it can be authenticated to verify the integrity and signature of the asset before deployment to a production environment.\nWhen an asset is authenticated, vcn will verify the integrity of the asset by comparing the hash of an asset with the signed hash stored by Trustcenter. If the hash of the asset matches the signed hash stored by Trustcenter and that asset is marked as Trusted, vcn will return a success message.\nUsing vcn to authenticate an asset # To authenticate an asset, which verifies the integrity of the asset by comparing it with the signed hash stored immutably by Trustcenter, use the vcn authenticate command:\nvcn authenticate \u0026lt;asset\u0026gt; vcn will query your immutable ledger in Trustcenter for a notarized record of the asset. If the record is found and the asset has been marked as Trusted, the asset has been authenticated and can be released to production.\nAuthenticate with a specific signerID with vcn # Using signerID:\nvcn authenticate --signerID \u0026lt;signerID\u0026gt; \u0026lt;asset\u0026gt; Authenticate multiple assets with vcn # To authenticate assets in batches, you can use xargs to call vcn authenticate on each asset in a directory:\nls | xargs vcn authenticate "},{"id":8,"href":"/sbom-guide/vcn-usage/labeling-assets/","title":"Labeling Assets","section":"Using vcn with Trustcenter","content":" Managing Assets with Labels # Codenotary Trustcenter can associate labels with your notarized artifacts to provide an additional level of metadata for authentication. Labels can be used to indicate the intended use of an artifact, such as production, staging, or development. Labels can also be used to indicate the type of artifact, such as library, binary, or container.\nLabels can be appended to, deleted from, or overwritten on an artifact when the vcn notarize command is run by passing the --labels-add, --labels-del, or --labels-set flags, as illustrated below.\nvcn Labeling Example # We can begin by notarizing an artifact with the --labels-add flag:\n❯ vcn n image://example --labels-add \u0026#39;label1,label2,label3\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . SignerID: demo-signer Apikey revoked: no Status: TRUSTED Labels: label1 (added), label2 (added), label3 (added) The asset can then be notarized again with the --labels-del flag to remove one of the labels from our signature for the artifact:\n❯ vcn notarize image://example --labels-del \u0026#39;label3\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label3 (removed) ❯ vcn inspect image://example --labels Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label1, label2 Then, after using the --labels-set flag to overwrite the existing labels on the artifact, we can use the --labels-add flag to append a final label to the artifact:\n❯ vcn notarize image://example --labels-set \u0026#39;label4,label5\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label4, label5 ❯ vcn notarize image://example --labels-add \u0026#39;label6\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label6 (added) ❯ vcn inspect image://example --labels Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label4, label5, label6 These labels provide an additional layer of metadata, and can be used to alter the results of the vcn authenticate command. For example, if we run the vcn authenticate command with the --label flag, the result will vary depending on the state of the asset\u0026rsquo;s labels:\nvcn inspect \u0026lt;artifact\u0026gt; --label \u0026#39;demo\u0026#39; How labels are used in authentication # If the artifact was marked Trusted, and the label demo is assigned, then the status is TRUSTED. the label demo is missing, then the status is UNKNOWN. If the artifact was marked Untrusted/Unsupported, and the label demo is assigned, then the status is UNTRUSTED/UNSUPPORTED (respectively). the label demo is missing, then the status is UNKNOWN. "},{"id":9,"href":"/sbom-guide/vcn-usage/bom-authentication/","title":"Authenticating SBOMs","section":"Using vcn with Trustcenter","content":" Notarizing and Authenticating Software Bills of Materials (SBOMs) with Trustcenter # When a Software Bill of Materials (SBOM) is notarized by vcn for a container image, codebase, or other build artifact, that asset\u0026rsquo;s entire manifest of dependencies is also notarized and they are immutably associated with one another.\nThis process creates a chain of custody for the asset and its dependencies, allowing you to check the integrity of the asset, track which artifacts are deployed on your infrastructure, and ensure untrusted dependencies never reach production.\nResolving dependencies with vcn # You can use the vcn bom command to collect and display an artifact\u0026rsquo;s manifest of dependencies:\nvcn bom \u0026lt;artifact\u0026gt; Example: vcn bom Example command:\nvcn bom image://python:3.10-alpine Output:\n:\talpine-baselayout-data@3.2.0-r22 :\tmusl@1.2.3-r0 :\tbusybox@1.35.0-r17 :\talpine-baselayout@3.2.0-r22 :\talpine-keys@2.4-r1 :\tca-certificates-bundle@20220614-r0 :\tlibcrypto1.1@1.1.1q-r0 :\tlibssl1.1@1.1.1q-r0 :\tssl_client@1.35.0-r17 :\tzlib@1.2.12-r3 :\tapk-tools@2.12.9-r3 :\tscanelf@1.3.4-r0 :\tmusl-utils@1.2.3-r0 :\tlibc-utils@0.7.2-r3 :\tca-certificates@20220614-r0 :\ttzdata@2022a-r0 :\tncurses-terminfo-base@6.3_p20220521-r0 :\tncurses-libs@6.3_p20220521-r0 :\tlibbz2@1.0.8-r1 :\tsqlite-libs@3.38.5-r0 :\tlibffi@3.4.2-r1 :\tgdbm@1.23-r0 :\txz-libs@5.2.5-r1 :\texpat@2.4.8-r0 :\tlibintl@0.21-r2 :\tlibtirpc-conf@1.3.2-r1 :\tkrb5-conf@1.0-r2 :\tlibcom_err@1.46.5-r0 :\tkeyutils-libs@1.6.3-r1 :\tlibverto@0.3.2-r0 :\tkrb5-libs@1.19.3-r0 :\tlibtirpc@1.3.2-r1 :\tlibnsl@2.0.0-r0 :\tlibuuid@2.38-r1 :\treadline@8.1.2-r0 :\t.python-rundeps@20220907.224335 Notarizing an artifact\u0026rsquo;s bill of materials # You can make use of a bill of materials by notarizing it together with the artifact, using the vcn notarize command and the --bom flag:\nvcn notarize --bom \u0026lt;artifact\u0026gt; # Short form of command: vcn n --bom \u0026lt;artifact\u0026gt; Authenticating an artifact\u0026rsquo;s bill of materials # After an artifact has been notarized with its bill of materials, you can authenticate the artifact and its dependencies, using the vcn authenticate command and the --bom flag:\nvcn authenticate --bom \u0026lt;artifact\u0026gt; # Short form of command: vcn a --bom \u0026lt;artifact\u0026gt; "},{"id":10,"href":"/sbom-guide/vcn-usage/managing-dependencies/","title":"Working with Dependencies","section":"Using vcn with Trustcenter","content":" Looking up known dependencies with vcn # To\nvcn a --bom-what-includes (\u0026lt;scheme\u0026gt;://\u0026lt;name\u0026gt;@\u0026lt;version\u0026gt; | --hash \u0026lt;hash\u0026gt;) Container support with vcn # To\nvcn \u0026lt;command\u0026gt; \u0026lt;scheme\u0026gt;://\u0026lt;image_or_container\u0026gt; [command options] Cascade operations with vcn # To\nvcn notarize|untrust|unsupport [command options ...] --bom-cascade [--bom-force] "},{"id":11,"href":"/sbom-guide/vcn-usage/dependency-authentication/","title":"Authenticating Dependencies","section":"Using vcn with Trustcenter","content":" Authenticating Trusted Dependencies # If we attempt to authenticate a Docker image which has not yet been notarized with our signing key, we receive a warning that the asset hasn\u0026rsquo;t yet been notarized:\n❯ vcn authenticate --bom docker://python:3.9-alpine Warning: c9b90024bc4d49b1fa0ea4673b6eb1db1058cd1cba4b840d336bedf803a0afcf was not notarized When we then notarize the image, all of its dependencies are resolved, authenticated with Trustcenter, signed, and marked as Trusted:\n❯ vcn notarize --bom image://python:3.9-alpine Your assets will not be uploaded. They will be processed locally. Notarization in progress... artifact notarized Kind: image Name: python:3.9-alpine Hash: dca341b7a3fdbe1aa117f97f55321e60fe54a177d6f58ab3373ece796aca52ef Metadata: hashtype=\u0026#34;SHA256\u0026#34; image={ \u0026#34;Architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-07 23:29:27.440739972 +0000 UTC\u0026#34;, \u0026#34;DockerVersion\u0026#34;: \u0026#34;20.10.12\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;0721d3b351f08b8a337ace23d9e1f99cc9cab25b3459b95359b85054c631a1af\u0026#34;, . . . } platform=\u0026#34;linux\u0026#34; architecture=\u0026#34;amd64\u0026#34; SignerID: demo-signer Apikey revoked: no Status: TRUSTED Dependencies: busybox@1.35.0-r17 899f82d8925d0659b628ab403a44a433bcd97a06 TRUSTED musl@1.2.3-r0 682bb42e6503a00152397e3db87be4602d566ac4 TRUSTED alpine-keys@2.4-r1 1417c88edb049afbaaa0d5e94a15c3726fe68f31 TRUSTED alpine-baselayout@3.2.0-r22 97afe73342be73255da8d7e0929d7f73a625ce4d TRUSTED . . . keyutils-libs@1.6.3-r1 19eb523e1d62d8b90431763aa3073d30e3283fb2 TRUSTED libuuid@2.38-r1 68bd5e9b8fe99566387e2ad7b7a44c8cf0936673 TRUSTED readline@8.1.2-r0 f676007339535e21de79acffbe7ae743a1f7168c TRUSTED .python-rundeps@20220907.232918 2d6f839e7b5f86c10811f4574f044b3b3ad53417 TRUSTED If we then attempt to authenticate the image we just notarized, we can confirm that it is now marked as Trusted:\nvcn authenticate --bom image://python:3.9-alpine Kind: image Name: python:3.9-alpine Hash: dca341b7a3fdbe1aa117f97f55321e60fe54a177d6f58ab3373ece796aca52ef Metadata: architecture=\u0026#34;amd64\u0026#34; hashtype=\u0026#34;SHA256\u0026#34; image={ \u0026#34;Architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-07 23:29:27.440739972 +0000 UTC\u0026#34;, \u0026#34;DockerVersion\u0026#34;: \u0026#34;20.10.12\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;0721d3b351f08b8a337ace23d9e1f99cc9cab25b3459b95359b85054c631a1af\u0026#34;, . . . } platform=\u0026#34;linux\u0026#34; SignerID: demo-signer Apikey revoked: no Status: TRUSTED Dependencies: alpine-baselayout-data@3.2.0-r22 bf84212e37b7916942f03263f997c94e39494525 TRUSTED musl@1.2.3-r0 682bb42e6503a00152397e3db87be4602d566ac4 TRUSTED busybox@1.35.0-r17 899f82d8925d0659b628ab403a44a433bcd97a06 TRUSTED alpine-baselayout@3.2.0-r22 97afe73342be73255da8d7e0929d7f73a625ce4d TRUSTED . . . keyutils-libs@1.6.3-r1 19eb523e1d62d8b90431763aa3073d30e3283fb2 TRUSTED libuuid@2.38-r1 68bd5e9b8fe99566387e2ad7b7a44c8cf0936673 TRUSTED readline@8.1.2-r0 f676007339535e21de79acffbe7ae743a1f7168c TRUSTED .python-rundeps@20220907.232918 2d6f839e7b5f86c10811f4574f044b3b3ad53417 TRUSTED Let\u0026rsquo;s say there is a hypothetical vulnerability discovered in the package keyutils-libs@1.6.3-r1, and we want to ensure we don\u0026rsquo;t run any containers based on images containing this dependency.\nWe can take the untrusted dependency\u0026rsquo;s hash and mark it as untrusted:\n❯ vcn untrust --hash 19eb523e1d62d8b90431763aa3073d30e3283fb2 Your assets will not be uploaded. They will be processed locally. Notarization in progress... artifact notarized Name: keyutils-libs Hash: 19eb523e1d62d8b90431763aa3073d30e3283fb2 Metadata: hashtype=\u0026#34;SHA1\u0026#34; license=\u0026#34;GPL-2.0-or-later LGPL-2.0-or-later\u0026#34; version=\u0026#34;1.6.3-r1\u0026#34; SignerID: demo-signer Apikey revoked: no Status: UNTRUSTED Now, when we attempt to notarize any assets that contain our known-vulnerable dependency, we will see that the notarization fails:\n❯ vcn notarize --bom image://python:3.10-alpine Dependency keyutils-libs@1.6.3-r1 trust level is UNTRUSTED Error: some dependencies have insufficient trust level so artifact cannot be notarized. You can override it with --bom-force option Because the keyutils-libs@1.6.3-r1 dependency has already been marked as untrusted with our current signing key, any future attempts to notarize an asset containing that dependency will fail.\n"},{"id":12,"href":"/sbom-guide/vcn-usage/bom-interoperability/","title":"Working with Other Tools","section":"Using vcn with Trustcenter","content":" Exchanging Data with Other Tools # Import from spfx and cyclonedx # TODO.\nExport to spfx or cyclonedx # TODO.\n"},{"id":13,"href":"/sbom-guide/reference/glossary/notarize/","title":"Notarize","section":"Glossary","content":" Notarize (definition) # "},{"id":14,"href":"/sbom-guide/examples/vulnerability-search/","title":"Searching for Vulnerabilities","section":"Examples \u0026 Use Cases","content":" Searching for Vulnerabilities with Trustcenter # "}]