[{"id":0,"href":"/sbom-guide/sbom-intro/sbom-intro/","title":"Introduction","section":"Understanding SBOMs","content":" Introduction to Software Bills of Materials (SBOMs) # A Software Bill of Materials (SBOM) is a manifest which uniquely identifies and enumerates the software dependencies contained within a codebase, build artifact, or runtime container. A dynamic SBOM can further integrate information from vulnerability scanners to help ensure the integrity of your software supply chain.\nWhat is motivating the need for SBOMs? # To quote President Biden\u0026rsquo;s Executive Order 14028 on Improving the Nation’s Cybersecurity:\n[T]he trust we place in our digital infrastructure should be proportional to how trustworthy and transparent that infrastructure is, and to the consequences we will incur if that trust is misplaced.\nThis order calls for transparency in the software supply chain, and SBOMs are a key part of that transparency. Notably, the policies laid out in this order will require vendors to provide SBOMs for all software they sell to the federal government, which will result in more vendors requesting SBOMs from their upstream suppliers.\nThe tooling and standards for SBOMs are continuing to mature, and as it becomes increasingly important for developers of both proprietary and open source software to generate SBOMs for their projects, the integration of SBOMs into software development workflows will become more widespread. A pilot program created by the above order shows the potential for how SBOMs can be used to communicate the security posture of software products (emphasis added):\n[The executive order] creates a pilot program to create an “energy star” type of label so the government – and the public at large – can quickly determine whether software was developed securely. Too much of our software, including critical software, is shipped with significant vulnerabilities that our adversaries exploit. This is a long-standing, well-known problem, but for too long we have kicked the can down the road. We need to use the purchasing power of the Federal Government to drive the market to build security into all software from the ground up.\nWhat is contained in a Software Bill of Materials? # Generally speaking, an SBOM is a nested inventory of uniquely-identified dependencies.\nFrom the NTIA\u0026rsquo;s SBOM FAQ (pdf) answer about what should be included in an SBOM:\nAn SBOM should contain some combination of the following baseline information: author name, supplier name, component name, version string, component hash, unique identifier, and relationship. Licensing, pedigree, provenance, should also be included, if available.\nWhen an SBOM is generated by a tool such as Codenotary\u0026rsquo;s cas CLI, the complete inventory of included software components is generated locally—using the dependency trees assembled by build tools and package managers.\nAssembled SBOMs can be shared between projects through interchange formats such as SPDX. That specification provides a common data format for sharing information about the provenance, licenses, and security information associated with a given component.\nOther variants of SBOMs have appeared alongside the full SPDX specification, such as SPDX Lite, a subset of the full specification, and CycloneDX, a lightweight standard designed for application security contexts.\nHow is it used? # Because an SBOM is fundamentally a metadata file meant to inventory components in use, a straightforward use case for these manifests is in determining what software is running where. When new vulnerabilities emerge (e.g. the log4j vulnerability), an inventory of all software components running on your infrastructure enables removal of these threats. When an SBOM is included in a dynamic, searchable SBOM database, developers can quickly find specific dependencies within their production assets.\nFrom a security perspective, SBOMs increase transparency of the software supply chain and allow projects to avoid including dependencies with known vulnerabilities. When build artifacts are scanned for components with known vulnerabilities while in the build pipeline—long before the those vulnerabilities ever reach your production environment—the risk of releasing known-dangerous components is reduced.\nWhen using CAS, notarized assets can be marked as Unsupported, and you configure the cas CLI to exit with an error when those unsupported dependencies are encountered. In addition to the security benefits of notarized SBOMs, uniquely-identified assets being marked as Unsupported helps keep outdated components from being deployed.\nEnriched SBOMs like those from Codenotary Trustcenter track metadata about runtime environments (in addition to component dependencies), such as which Docker images contain a given dependency, providing additional visibility into deployments.\n"},{"id":1,"href":"/sbom-guide/sbom-intro/sbom-concepts/","title":"SBOM Concepts","section":"Understanding SBOMs","content":" SBOM Concepts # Improving Transparency # When the dependencies of a software asset are enumerated in an SBOM, it becomes possible to track where artifacts are deployed when new vulnerabilities are discovered. This is especially useful when the SBOM is stored in a searchable database (such as Codenotary Trustcenter).\nA software bill of materials is an important part of software supply chain security, because it surfaces the various artifacts that are bundled with a given software asset and enables developers to quickly identify and remove vulnerable components.\nBeyond the security applications of SBOMs, they also play a role in licensing and regulatory compliance. For example, the Software Package Data Exchange (SPDX) is a major standard SBOM format which communicates \u0026ldquo;the components, licenses, and copyrights associated with a software package,\u0026rdquo; and most developers have probably already encountered SPDX license identifiers in their projects (e.g. MIT or GPL-3.0-or-later).\nTaking an Inventory of Software Dependencies # Ideally, every software project and build artifact would come with an SBOM attached. While that may not always be feasible, any developer can create an SBOM for their project which enumerates the dependencies of their project—and defines the relationship between those dependencies and the project.\nDependency Relationships\nFrom Software Bill of Materials Elements and Considerations by the National Telecommunications and Information Administration, US Department of Commerce:\n[T]he “dependency relationship” generally refers to the idea that one component is included in another component, but could be expanded to also include referencing standards, which tools were used, or how software was compiled or built. [\u0026hellip;] As one SBOM document notes, “[c]omponent identification is fundamental to SBOM and needs to scale globally across diverse software ecosystems, sectors, and markets.” Documenting the Software Supply Chain # Although the relationship between a project and its dependencies generally refers to which components are included in a piece of software, the relationships between two components in an SBOM can be defined in any number of ways that describe various points in the creation of an artifact.\nFor example, the SPDX specification not only provides a mechanism for defining relations such as DEPENDS_ON and RUNTIME_DEPENDENCY_OF, but also allows for defining relationships with the DOCUMENTATION_OF a project or the BUILD_TOOL_OF of a given build artifact.\nEnumerating Dependencies # Tools such as Syft and CodeNotary\u0026rsquo;s cas CLI can scan container images and codebases for libraries and other dependencies included within. When the SBOMs generated by these tools are shared with downstream consumers of a software project, they can be included in the SBOM for that project to track the provenance of each component in the entire dependency tree.\nStructuring SBOMs # A software bill of materials is typically structured according to an interchange format for SBOMs, such as SPDX or CycloneDX. The information architecture of an SBOM varies depending on the tool that is used to generate it, as well as the purpose of the SBOM and the needs of downstream consumers, but the basic set of properties is generally consistent between formats.\nBaseline Component Information\nThe \u0026ldquo;baseline component information\u0026rdquo; of an SBOM, according to Software Bill of Materials Elements and Considerations by the NTIA:\nSupplier name Component name Version of the component Cryptographic hash of the component Any other unique identifier Dependency relationship Author of the SBOM data An SBOM should include information that uniquely associates it with the software artifact it describes, typically the name and version identifier of the asset, along with a cryptographic hash of the files that constitute the asset. Beyond that, to be used in any sort of meaningful way, an SBOM should include information about the relationship between the asset and its dependencies.\n"},{"id":2,"href":"/sbom-guide/sbom-intro/spdx-documents/","title":"SPDX Documents","section":"Understanding SBOMs","content":" Documenting Software Artifacts with SBOMs # The Software Package Data Exchange (SPDX) Specification is an open standard for communicating software bill of materials (SBOM) information.\nSPDX is an initiative of the Linux Foundation created to develop tools and formats for communicating the licensing information of software packages. Most developers have probably already encountered one specification from SPDX in the form of the SPDX License List, which is \u0026ldquo;a list of commonly found licenses and exceptions used for open source and other collaborative software.\u0026rdquo; If you\u0026rsquo;ve defined a license in a Node project\u0026rsquo;s package.json file or a Python project\u0026rsquo;s pyproject.toml file, you\u0026rsquo;ve already interacted with a core component of an SPDX SBOM.\nThe Software Package Data Exchange (SPDX) Specification defines a data exchange format for information about software packages and related content, \u0026ldquo;collected and shared in a common format with the goal of saving time and improving data accuracy.\u0026rdquo;\nSPDX Document Examples\nThe examples in this section are taken from the SPDX YAML Example, v2.2.2. The content presented in some of the examples below has been modified or reformatted as necessary for the purposes of this guide. For full examples in each of the available formats for SPDX documents, have a look at Producing/Consuming SPDX Documents on the SPDX website.\nContent omitted for formatting or clarity may be replaced with an ellipsis (. . .).\nSPDX for Licensing Compliance # Let\u0026rsquo;s have a look at how SPDX enables licensing compliance, as a demonstration of the practical applications of SBOMs.\nThe only mandatory section of an SPDX document is the metadata for the document itself, where the document creator can define the SPDX Specification Version, a data license for the information contained in the SBOM document itself (always CC0-1.0, to ensure SBOM metadata can be freely used), the SPDX Identifier that references the document itself, and several other attributes that explain how the SPDX document was created.\nDefining a Software Package # In the additional sections of an SPDX document, the licensing relationships between a software project and its dependencies are defined in a structured way. When an SPDX document is describing a software package, it first defines the metadata of the package that the document describes, including the package\u0026rsquo;s name, version, supplier, the URI of the document\u0026rsquo;s source project, and checksums for the package\u0026rsquo;s distributed file.\npackages: - SPDXID: \u0026#34;SPDXRef-Package\u0026#34; name: \u0026#34;glibc\u0026#34; originator: \u0026#34;Organization: ExampleCodeInspect (contact@example.com)\u0026#34; packageFileName: \u0026#34;glibc-2.11.1.tar.gz\u0026#34; packageVerificationCode: packageVerificationCodeExcludedFiles: - \u0026#34;./package.spdx\u0026#34; packageVerificationCodeValue: \u0026#34;d6a770ba38583ed4bb4525bd96e50461655d2758\u0026#34; sourceInfo: \u0026#34;uses glibc-2_11-branch from git://sourceware.org/git/glibc.git.\u0026#34; summary: \u0026#34;GNU C library.\u0026#34; supplier: \u0026#34;Person: Jane Doe (jane.doe@example.com)\u0026#34; versionInfo: \u0026#34;2.11.1\u0026#34; checksums: - algorithm: \u0026#34;MD5\u0026#34; checksumValue: \u0026#34;624c1abb3664f4b35547e7c73864ad24\u0026#34; - algorithm: \u0026#34;SHA1\u0026#34; checksumValue: \u0026#34;85ed0817af83a24ad8da68c2b5094de69833983c\u0026#34; - algorithm: \u0026#34;SHA256\u0026#34; checksumValue: \u0026#34;11b6d3ee554eedf79299905a98f9b9a04e498210b59f15094c916c91d150efcd\u0026#34; downloadLocation: \u0026#34;http://ftp.gnu.org/gnu/glibc/glibc-ports-2.15.tar.gz\u0026#34; Defining a Package\u0026rsquo;s License # For defining the license of a software package and its relationship with the package\u0026rsquo;s dependencies, SPDX provides several different properties for communicating any licensing information surfaced by a license scanner application. At the highest level, where the package\u0026rsquo;s actual licensing information is defined, an SPDX document may incorporate information extracted directly from the package, any copyright and licensing information found from scanning the source code, and any conclusions that the document creator (such as a license scanning tool) has made about how the licenses defined in the package apply:\npackages: - SPDXID: \u0026#34;SPDXRef-Package\u0026#34; . . . attributionTexts: - \u0026#34;The GNU C Library is free software. See the file COPYING.LIB for copying conditions,\\ \\ and LICENSES for notices about a few contributions that require these additional\\ \\ notices to be distributed. License copyright years may be listed using range\\ \\ notation, e.g., 1996-2015, indicating that every year in the range, inclusive,\\ \\ is a copyrightable year that would otherwise be listed individually.\u0026#34; copyrightText: \u0026#34;Copyright 2008-2010 John Smith\u0026#34; filesAnalyzed: true licenseConcluded: \u0026#34;(LGPL-2.0-only OR LicenseRef-3)\u0026#34; licenseDeclared: \u0026#34;(LGPL-2.0-only AND LicenseRef-3)\u0026#34; licenseInfoFromFiles: - \u0026#34;GPL-2.0-only\u0026#34; - \u0026#34;LicenseRef-2\u0026#34; - \u0026#34;LicenseRef-1\u0026#34; licenseComments: \u0026#34;The license for this project changed with the release of version\\ \\ x.y. The version of the project included here post-dates the license change.\u0026#34; The metadata defining how an SPDX document\u0026rsquo;s contents were generated allows for downstream consumers of an SBOM to determine how the included information meets their particular needs. This information is critical for ensuring that the SBOM is accurate and complete; for example, if a package scanner only returns the license declared for a package itself (without scanning the source code to determine if other licenses apply), it may not meet the needs of an organization that incorporates components from many different open source projects into its own products.\nDefining the Constituents of a Package # When a license scanner produces an SPDX document for a software project, if it detects licensing information for some code buried deep inside the project, it may surface this information in a dedicated \u0026ldquo; other licensing information detected\u0026rdquo; section.\nhasExtractedLicensingInfos: - licenseId: \u0026#34;LicenseRef-1\u0026#34; extractedText: \u0026#34;/*\\n * (c) Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\\ \\ 2008, 2009 Hewlett-Packard Development Company, LP\\n * All rights reserved.\\n\\ \\ *\\n * Redistribution and use in source and binary forms, with or without\\n *\\ \\ modification, are permitted provided that the following conditions\\n * are met:\\n\\ \\ * 1. Redistributions of source code must retain the above copyright\\n * notice,\\ . . . */\u0026#34; - licenseId: \u0026#34;LicenseRef-2\u0026#34; extractedText: \u0026#34;This package includes the GRDDL parser developed by Hewlett Packard\\ \\ under the following license:\\n� Copyright 2007 Hewlett-Packard Development Company,\\ \\ LP\\n\\nRedistribution and use in source and binary forms, with or without modification,\\ \\ are permitted provided that the following conditions are met: \\n\\nRedistributions\\ . . . \u0026#34; - licenseId: \u0026#34;LicenseRef-4\u0026#34; extractedText: \u0026#34;/*\\n * (c) Copyright 2009 University of Bristol\\n * All rights reserved.\\n\\ \\ *\\n * Redistribution and use in source and binary forms, with or without\\n *\\ . . . */\u0026#34; - licenseId: \u0026#34;LicenseRef-Beerware-4.2\u0026#34; comment: \u0026#34;The beerware license has a couple of other standard variants.\u0026#34; extractedText: \u0026#34;\\\u0026#34;THE BEER-WARE LICENSE\\\u0026#34; (Revision 42):\\nphk@FreeBSD.ORG wrote\\ \\ this file. As long as you retain this notice you\\ncan do whatever you want with\\ \\ this stuff. If we meet some day, and you think this stuff is worth it, you can\\ \\ buy me a beer in return Poul-Henning Kamp\u0026#34; name: \u0026#34;Beer-Ware License (Version 42)\u0026#34; seeAlsos: - \u0026#34;http://people.freebsd.org/~phk/\u0026#34; - licenseId: \u0026#34;LicenseRef-3\u0026#34; comment: \u0026#34;This is tye CyperNeko License\u0026#34; extractedText: \u0026#34;The CyberNeko Software License, Version 1.0\\n\\n \\n(C) Copyright\\ \\ 2002-2005, Andy Clark. All rights reserved.\\n \\nRedistribution and use in source\\ \\ and binary forms, with or without\\nmodification, are permitted provided that\\ . . . \u0026#34; name: \u0026#34;CyberNeko License\u0026#34; seeAlsos: - \u0026#34;http://people.apache.org/~andyc/neko/LICENSE\u0026#34; - \u0026#34;http://justasample.url.com\u0026#34; The licensing information from this SBOM comprises three different proprietary licenses and a common open source licens with several known variants. The license scanner has found licenses attached to specific pieces of source code within the project, and in this particular example, compliance with those licenses is achieved by retaining the original copyright and license information in each of source files.\nWhen the licenses found within a project impose restrictions on using the code, the \u0026ldquo;other licensing information detected\u0026rdquo; section of the SBOM provides downstream consumers with an understanding of what those restrictions entail. For example, if a project incorporates and modifies large pieces of code from projects that are licensed as GPL-2.0-only and GPL-2.0-or-later, licensing those modifications as GPL-3.0-or-later would not be compliant with the original license of some of the code.\nWhy does this matter? # As this example demonstrates, fully understanding the licensing of a software artifact and its dependencies is necessary to have any idea if you are complying with those terms.\nLikewise, if you want to ensure dependencies with known vulnerabilities are not included in your projects, you need to have a full picture of the components comprising your software. This brings us to the security applications of SBOMs\u0026hellip;\n"},{"id":3,"href":"/sbom-guide/sbom-intro/supply-chain/","title":"Software Security","section":"Understanding SBOMs","content":" Increasing the Security of Software # When it comes to using SBOMs to keep software secure, there are two main use cases:\nIdentifying vulnerable components. By enumerating the components contained in a given software artifact, you can identify which components deployed on your infrastructure are vulnerable to known explots. Ensuring the integrity of software components. Likewise, ensuring the integrity of your build artifacts requires keep records that uniquely identify an asset and its provenance. It\u0026rsquo;s impossible to ensure that you are only deploying trusted components on your infrastructure without records of all of the trusted components that are available for deployment. In both of these cases, the SBOM plays the critical role of providing a complete inventory of the components in use by a given software project—without understanding what components comprise your software artifacts, it\u0026rsquo;s impossible to know whether any of them are vulnerable or have been tampered with. In security applications, for this reason, SBOMs primarily serve as a source of truth for the components comprising a given asset.\nTake a look at the following excerpt from a CycloneDX SBOM generated by Codenotary\u0026rsquo;s CAS tool for the python:3.10-alpine Docker image:\n{ \u0026#34;bomFormat\u0026#34;: \u0026#34;CycloneDX\u0026#34;, \u0026#34;specVersion\u0026#34;: \u0026#34;1.3\u0026#34;, \u0026#34;version\u0026#34;: 1, \u0026#34;metadata\u0026#34;: { \u0026#34;tools\u0026#34;: [ { \u0026#34;vendor\u0026#34;: \u0026#34;Codenotary\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;cas\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;v1.0.3\u0026#34; } ], \u0026#34;component\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;python:3.10-alpine\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;\u0026#34; } }, \u0026#34;components\u0026#34;: [ { \u0026#34;bom-ref\u0026#34;: \u0026#34;python:3.10-alpine-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;library\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;.python-rundeps\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;20220907.223701\u0026#34;, \u0026#34;hashes\u0026#34;: [ { \u0026#34;alg\u0026#34;: \u0026#34;SHA-1\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;f3105e48f2a5caae5d0d2b6cbba5468a06a111c2\u0026#34; } ], \u0026#34;purl\u0026#34;: \u0026#34;pkg:generic/.python-rundeps@20220907.223701\u0026#34;, \u0026#34;properties\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;LinkType\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Static\u0026#34; } ] }, { \u0026#34;bom-ref\u0026#34;: \u0026#34;python:3.10-alpine-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;library\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;alpine-baselayout\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;3.2.0-r22\u0026#34;, \u0026#34;hashes\u0026#34;: [ { \u0026#34;alg\u0026#34;: \u0026#34;SHA-1\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;3c6c70ccb77b490fd2663506ae7727a638eda4a6\u0026#34; } ], # # # }, # # # In this example, the SBOM begins by defining the software artifact that was scanned, as well as the tool that was used to complete the scan. Beyond that, we have a set of components that were discovered in the Docker image, using the native package manager of this image itself (Alpine\u0026rsquo;s apk). The object defining each components gives the component\u0026rsquo;s name, the type of component (in this case, library components), the specific version of the component in the image, and a cryptographic hash identifying each component (SHA-1, in this case, as that is the algorithm used by apk to generate hashes).\nAlso included is information describing the runtime environment of each package in the operating system of the image, such as whether it\u0026rsquo;s a static or dynamic binary.\nIf we use the same tool to generate an SBOM in a different format, you will see that the scanner returns the same information, but formatted according to a different specification. For example, here is the same SBOM as above in SPDX format:\nSPDXVersion: SPDX-2.2 DataLicense: CC0-1.0 SPDXID: SPDXRef-DOCUMENT DocumentName: python:3.10-alpine DocumentNamespace: http://spdx.org/spdxdocs/python:3.10-alpine-64ef73cf-f862-4602-b384-42a9803c8098 Creator: Tool: Codenotary cas Created: 2022-09-30T18:44:21Z ##### Software components PackageName: .python-rundeps SPDXID: SPDXRef-Package-1 PackageVersion: 20220907.223701 PackageDownloadLocation: NOASSERTION FilesAnalyzed: false PackageChecksum: SHA1: f3105e48f2a5caae5d0d2b6cbba5468a06a111c2 PackageSourceInfo: \u0026lt;text\u0026gt;pkg:generic/.python-rundeps@20220907.223701\u0026lt;/text\u0026gt; PackageLicenseConcluded: NOASSERTION PackageLicenseDeclared: NOASSERTION PackageCopyrightText: NOASSERTION PackageComment: \u0026lt;text\u0026gt;Static, Direct\u0026lt;/text\u0026gt; PackageName: alpine-baselayout SPDXID: SPDXRef-Package-2 PackageVersion: 3.2.0-r22 PackageDownloadLocation: NOASSERTION FilesAnalyzed: false PackageChecksum: SHA1: 3c6c70ccb77b490fd2663506ae7727a638eda4a6 PackageSourceInfo: \u0026lt;text\u0026gt;pkg:generic/alpine-baselayout@3.2.0-r22\u0026lt;/text\u0026gt; PackageLicenseConcluded: GPL-2.0-only PackageLicenseDeclared: NOASSERTION PackageCopyrightText: NOASSERTION PackageComment: \u0026lt;text\u0026gt;Static, Direct\u0026lt;/text\u0026gt; . . . As before, the SBOM defines the software artifact that was scanned, as well as the packages found within the Docker image. This time, the SBOM is formatted according to the SPDX specification, which is a popular format for software bill of materials. The metadata provided by the SPDX specification is a bit more verbose than the CycloneDX specification, but it can also provide more metadata describing the provenance of each component, including the license under which each component is distributed.\nIf we have a way to indentify components, how can we use that information to ensure the integrity of our software artifacts? And more importantly, how can we use that information to ensure we aren\u0026rsquo;t deploying vulnerable components on our servers?\nEnsuring the Integrity of Software Artifacts # Although identifying and recording assets is critical to ensuring their integrity, an SBOM alone is not an indicator of the trust of the software—only a manifest of the components that comprise the artifact. When you have a record of the hash of each component, it becomes possible to ensure that a software component in use hasn\u0026rsquo;t been modified since the last time it was scanned.\nHow can we use these manifests to ensure we are only deploying trusted software? When you are using a tool like Codenotary\u0026rsquo;s cas, the workflow for keeping software artifacts secure generally has three main steps:\nCryptographically signing the Software Bill of Materials generated for each software asset (codebase, container image, library package, build artifact, etc.). Storing the signed SBOM in a trusted location, along with any relevant supporting metadata (such as which components are trusted, which are unsupported, etc.). Verifying the integrity of the software asset before it is deployed, by scanning the asset and comparing the result to the signed SBOM. Each of these three steps, however, raises a number of practical considerations:\nHow do we sign the SBOM? How do we indicate our level of trust for each component? How do we make a SBOM accessible from a trusted location? How do we even deploy a \u0026ldquo;trusted location\u0026rdquo;? How do we prevent someone from tampering with our \u0026ldquo;trusted location\u0026rdquo;? How do we securely update our asset metadata (e.g. the \u0026ldquo;trust level\u0026rdquo; of each component)? How do we verify a software asset is safe to deploy? One solution to many of these problems is to use a cryptographically-verifiable immutable database to store SBOMs and their associated metadata.\nIntroduction to immudb, or: What is an immutable database? # An immutable database stores data in cryptographically-verifiable data structures that make it possible to verify that the data has not been tampered with or corrupted in any way.\nIn an immutable database such as immudb, the data is stored in such a way that:\nExisting data is never overwritten (that is, the database is append-only and individual records are immutable). All changes to the database—such as record creation (by appending a new record) or modification (by appending a new version of an existing record)—are tracked and auditable. Any tampering of the data is detectable by the database itself and by any client that interacts with the database (by verifying the hash tree of the data). Responses from the database can be cryptographically signed by the server and verified by the client (to ensure the source of the data is authentic). These characteristics of an immutable database offer an answer to most of the practical considerations raised above: an immutable database can be used as a \u0026ldquo;trusted location,\u0026rdquo; because you only need to trust well-known cryptographic hash algorithms to verify the integrity and authenticity of the stored data.\nKeeping Deployments Safe with SBOMs # When security metadata is stored in an immutable database, it becomes possible to create a verifiable chain of custody for each component deployed by your team. When you create an SBOM using one of Codenotary\u0026rsquo;s tools (cas with Community Attestation Service or vcn with Trustcenter), that manifest can be signed with a key that is associated with an individual developer or CI/CD pipeline.\nSigning software assets # This notarization process creates an immutable record of an asset\u0026rsquo;s manifest, the level of trust declared for each component, and a cryptographic signature which authenticates the source of the SBOM. This process creates cryptographic proof that an SBOM was created by a trusted source, and that it has not been modified after it was signed.\nNow, consider what happens when a Docker image is signed with cas:\n❯ cas notarize --bom docker://python:3.9-alpine Resolving dependencies... Authenticating dependencies... 100% |██████████████████████████████████████████████████████| (36/36, 58 it/s) Notarizing 36 dependencies ... 100% |██████████████████████████████████████████████████████| (36/36, 39 it/s) .python-rundeps@20220907.231849 b9bddeccfab9c3d7731f6b39360dcf3cfdeb1b7f Trusted alpine-baselayout@3.2.0-r22 3c6c70ccb77b490fd2663506ae7727a638eda4a6 Trusted alpine-baselayout-data@3.2.0-r22 d6554033bbe7f571edc82954fd97e59aa4c7f045 Trusted . . . Your assets will not be uploaded. They will be processed locally. Kind: docker Name: docker://python:3.9-alpine Hash: c9b90024bc4d49b1fa0ea4673b6eb1db1058cd1cba4b840d336bedf803a0afcf Metadata: architecture=\u0026#34;arm64\u0026#34; docker={ \u0026#34;Architecture\u0026#34;: \u0026#34;arm64\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-07T23:19:03.452996827Z\u0026#34;, \u0026#34;DockerVersion\u0026#34;: \u0026#34;20.10.12\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;sha256:c9b90024bc4d49b1fa0ea4673b6eb1db1058cd1cba4b840d336bedf803a0afcf\u0026#34;, . . . } platform=\u0026#34;linux\u0026#34; version=\u0026#34;3.9-alpine\u0026#34; SignerID: bmlja0Babcdefgh12345== Apikey revoked: no Status: TRUSTED Dependencies: .python-rundeps@20220907.231849 b9bddeccfab9c3d7731f6b39360dcf3cfdeb1b7f alpine-baselayout@3.2.0-r22 3c6c70ccb77b490fd2663506ae7727a638eda4a6 alpine-baselayout-data@3.2.0-r22 d6554033bbe7f571edc82954fd97e59aa4c7f045 alpine-keys@2.4-r1 cffd2a49107574ba448f4b23b4bfc597676b9054 apk-tools@2.12.9-r3 bd9d72a8be3f3e5f046759c4e82086b6b7195622 busybox@1.35.0-r17 31ea3e2c718f4a2dee63d808a2e1156fdcfc15ba . . . We can see from this output the different ways our practical considerations from above are addressed:\nHow do we sign the SBOM? The SBOM is signed with a key that is associated with the developer or CI/CD pipeline that created it. How do we indicate our level of trust for each component? How do we make an SBOM accessible from a trusted location? How do we prevent someone from tampering with our \"trusted location\"? We associate a trust status with each component in the SBOM, referenced by the hash of each component. That transaction is signed by the developer or CI/CD pipeline, and is stored in a database that can be cryptographically verified. How do we even deploy a \"trusted location\"? The immutable database (immudb, specifically) backing the Community Attestation Service and Trustcenter product allows clients to act as auditors of the database, alerting any interested parties if the state of the database fails to validate in any way. CAS, for example, is audited by clients operated by Codenotary and by the community. How do we securely update our asset metadata (e.g. the \"trust level\" of each component)? Because an immutable database is append-only, the only way to update a value in a record is to create a new version of that record with the updated value. Not only does this ensure that any changes to past data result in an invalid hash tree, but it also means each update is associated with a signing key and recorded in a transaction log. How do we verify a software asset is safe to deploy? We authenticate the asset against a stored SBOM! That brings us to\u0026hellip;\nAuthenticating software assets # When you authenticate an asset with cas or vcn, you are verifying that the asset\u0026rsquo;s manifest matches the signed SBOM data stored in an immutable database.\nThese tools scan a local asset to build a manifest of the components within, then check the hashes of the asset itself and each component against the trust values stored in the database. Then, if:\nall of the hashes are found in the database, the trust level of each component is at least as high as the level specified by the user (i.e. untrusted, unsupported, unknown, or trusted, with a default minimum of trusted), and the trusted components were signed by a trusted key (i.e. one that has not been revoked), then the asset is considered authenticated.\nConnecting the Pipelines # Fundamentally, an SBOM-based mechanism for authenticating software assets bridges the gaps in the chain of custody of a software asset, from the developer\u0026rsquo;s machine to any environment where it is eventually deployed.\nAt the beginning of any segment of the software supply chain where a software component is received from another party, we can enumerate the components in the asset, authenticate the manifest against an SBOM assembled by the asset\u0026rsquo;s creator, verify the level of trust for each component in the manifest (failing if any component is untrusted), and then proceed to use that authenticated asset in the next step of our software development pipeline.\nAt the end of any segment of the software supply chain where we hand off a software component to another custodian or deployment environment, we can generate an SBOM for our final artifact, authenticate the SBOM against our own records (failing if any component included in the final deliverable is untrusted), sign the SBOM to enable recipients of the asset to authenticate it, and then hand that notarized asset off to the next party in the software supply chain.\nOf course, with the right tools, these steps can be reduced to a single command at each end of the pipeline. When an asset enters the pipeline:\ncas authenticate --bom git://\u0026lt;source-code-for-build\u0026gt; # or vcn authenticate --bom git://\u0026lt;source-code-for-build\u0026gt; This ensures we\u0026rsquo;re only dealing with the assets we\u0026rsquo;re expecting to see. Then, when the build pipeline is finished:\ncas notarize --bom docker://\u0026lt;image-built-from-source\u0026gt; # or vcn notarize --bom image://\u0026lt;image-built-from-source\u0026gt; Notarizing the SBOM for the final artifact ensures that any downstream consumers of the asset can authenticate it and verify the chain of custody!\n"},{"id":4,"href":"/sbom-guide/reference/glossary/","title":"Glossary","section":"Reference","content":" Glossary # Notarize Notarize (definition) # "},{"id":5,"href":"/sbom-guide/vcn-usage/intro/","title":"Introduction to VCN","section":"Using vcn with Trustcenter","content":" Introduction to vcn # vcn is a command line tool that allows you to interact with Codenotary Trustcenter to notarize and authenticate your software assets. This documentation will guide you through the various ways you can use vcn to help manage the security of your software.\nSpecifying Assets in vcn Commands # Throughout this documentation, you\u0026rsquo;ll see the placeholder \u0026lt;artifact\u0026gt; used to refer to an asset that you want to authenticate or notarize. For example:\nvcn authenticate \u0026lt;artifact\u0026gt; The asset referred to by the \u0026lt;artifact\u0026gt; placeholder can be a file, directory, image, or git repository. The following are examples of how to specify an asset, where COMMAND is a placeholder for any vcn command that accepts an asset as an argument:\nvcn COMMAND \u0026lt;file\u0026gt; vcn COMMAND dir://\u0026lt;directory\u0026gt; vcn COMMAND image://\u0026lt;imageId\u0026gt; vcn COMMAND docker://\u0026lt;imageId\u0026gt; // deprecated, please use image vcn COMMAND podman://\u0026lt;imageId\u0026gt; vcn COMMAND git://\u0026lt;path_to_git_repo\u0026gt; vcn COMMAND --hash \u0026lt;hash\u0026gt; These docs will only use the \u0026lt;artifact\u0026gt; placeholder in examples, but the actual commands you run should specify the appropriate asset type based on one of the templates defined above.\nUsing the vcn CLI # To begin using the vcn CLI, you must first log in with your credentials for Codenotary Trustcenter. After you generate an API key in Trustcenter, you can log in with the vcn login command:\nvcn login --lc-host example.com If you are using vcn in a script, you can set the API key in the VCN_LC_API_KEY environment variable, and then run the vcn login command without the --lc-host flag:\nexport VCN_LC_API_KEY=\u0026lt;API_KEY\u0026gt; export VCN_LC_HOST=\u0026lt;TRUSTCENTER_DOMAIN\u0026gt; export VCN_LC_PORT=443 vcn login You can also specify the API key in an environment variable prefixed to the vcn login command.\nVCN_LC_API_KEY=\u0026lt;API_KEY\u0026gt; vcn login --lc-host \u0026lt;TRUSTCENTER_DOMAIN\u0026gt; However, by logging in without your API key present in the appropriate environment variable, the --signerID flag becomes mandatory.\n"},{"id":6,"href":"/sbom-guide/vcn-usage/notarizing-assets/","title":"Notarizing Assets","section":"Using vcn with Trustcenter","content":" Notarizing Assets # When using vcn with Codenotary Trustcenter, the notarization process creates a cryptographic signature of the asset and stores it in a cryptographically-verifiable immutable database (immudb). That signature can then be used to authenticate the asset and verify its integrity.\nNotarize an asset with vcn # The most basic way to notarize an asset is to pass the asset to the vcn notarize command:\nvcn notarize \u0026lt;artifact\u0026gt; This command will sign the combination of the asset\u0026rsquo;s name, version, and hash to unique identify it. vcn will then send the signature to Trustcenter, which will store an immutable record of the signature.\nNotarizing assets with dependencies # Passing the --bom flag to the vcn notarize command will notarize the asset itself, in combination with notarization the asset\u0026rsquo;s dependencies. This process will immutably associate the artifact with its dependencies in Trustcenter:\nvcn notarize --bom \u0026lt;artifact\u0026gt; Notarizing assets in bulk # If you need to notarize assets in bulk, you can supply a CSV file that enumerates the hash, name, and labels of each asset to the vcn notarize command:\nvcn notarize --import-file \u0026lt;csv_file\u0026gt; The contents of your CSV file should follow the format\nhash,name,labels where hash is the hash of the asset, name is the name of the asset, and labels is an optional list of semicolon-separated labels. For example, your CSV file will look something like this:\naddf340d683e7dc9be1859f4e9a85f5143d4b21c,libcrypto1.1@1.1.1q-r0,label1;label2 722a653f03c02836b5f6391bc588e28aff86e44b,libssl1.1@1.1.1q-r0,label2 2962576b068d3e220d1df7730a0fc5ac49a201a5,ssl_client@1.35.0-r17,label2;label3 124baa9bfd023f2c0308a11b13086c3c2c3ecfd1,zlib@1.2.12-r3,label1;label3 Add attachments to notarization transactions # To attach files containing user-defined supporting documentation (e.g., build pipeline metadata or deployment information) to a notarization transaction in Trustcenter, use the --attach flag to specify the path to the file and a label to identify it:\nvcn notarize \u0026lt;artifact\u0026gt; --attach=\u0026lt;ATTACHMENT_PATH\u0026gt;[:\u0026lt;ATTACHMENT_LABEL\u0026gt;] vcn notarize Flags Documentation --attach Add user defined file attachments. This flag can be repeated to include multiple attachments.\nIt\u0026rsquo;s possible to specify a label for each entry, by appending the label to the file path after a colon, for example: --attach=metadata.json:jobid123. When authenticating an asset with vcn authenticate, the same path and label can be specifed with the --attach flag to retrieve that attachment. The label alone can be specified with the --attach flag to retrieve all attachments, e.g. vcn a \u0026lt;artifact\u0026gt; --attach=jobid123.\n"},{"id":7,"href":"/sbom-guide/vcn-usage/authenticating-assets/","title":"Authenticating Assets","section":"Using vcn with Trustcenter","content":" Authenticating Assets with Trustcenter # After an asset has been notarized with Codenotary Trustcenter, it can be authenticated to verify the integrity and signature of the asset before deployment to a production environment.\nWhen an asset is authenticated, vcn will verify the integrity of the asset by comparing the hash of an asset with the signed hash stored by Trustcenter. If the hash of the asset matches the signed hash stored by Trustcenter and that asset is marked as Trusted, vcn will return a success message.\nUsing vcn to authenticate an asset # To authenticate an asset, which verifies the integrity of the asset by comparing it with the signed hash stored immutably by Trustcenter, use the vcn authenticate command:\nvcn authenticate \u0026lt;asset\u0026gt; vcn will query your immutable ledger in Trustcenter for a notarized record of the asset. If the record is found and the asset has been marked as Trusted, the asset has been authenticated and can be released to production.\nAuthenticate with a specific signerID with vcn # Using signerID:\nvcn authenticate --signerID \u0026lt;signerID\u0026gt; \u0026lt;asset\u0026gt; Authenticate multiple assets with vcn # To authenticate assets in batches, you can use xargs to call vcn authenticate on each asset in a directory:\nls | xargs vcn authenticate "},{"id":8,"href":"/sbom-guide/vcn-usage/labeling-assets/","title":"Labeling Assets","section":"Using vcn with Trustcenter","content":" Managing Assets with Labels # Codenotary Trustcenter can associate labels with your notarized artifacts to provide an additional level of metadata for authentication. Labels can be used to indicate the intended use of an artifact, such as production, staging, or development. Labels can also be used to indicate the type of artifact, such as library, binary, or container.\nLabels can be appended to, deleted from, or overwritten on an artifact when the vcn notarize command is run by passing the --labels-add, --labels-del, or --labels-set flags, as illustrated below.\nvcn Labeling Example # We can begin by notarizing an artifact with the --labels-add flag:\n❯ vcn n image://example --labels-add \u0026#39;label1,label2,label3\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . SignerID: demo-signer Apikey revoked: no Status: TRUSTED Labels: label1 (added), label2 (added), label3 (added) The asset can then be notarized again with the --labels-del flag to remove one of the labels from our signature for the artifact:\n❯ vcn notarize image://example --labels-del \u0026#39;label3\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label3 (removed) ❯ vcn inspect image://example --labels Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label1, label2 Then, after using the --labels-set flag to overwrite the existing labels on the artifact, we can use the --labels-add flag to append a final label to the artifact:\n❯ vcn notarize image://example --labels-set \u0026#39;label4,label5\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label4, label5 ❯ vcn notarize image://example --labels-add \u0026#39;label6\u0026#39; Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label6 (added) ❯ vcn inspect image://example --labels Name: example Hash: f34ed96bfd9f329f89ce3977373cef37ce5d0a4ba8c5ed4aebca785d649b9082 . . . Status: TRUSTED Labels: label4, label5, label6 These labels provide an additional layer of metadata, and can be used to alter the results of the vcn authenticate command. For example, if we run the vcn authenticate command with the --label flag, the result will vary depending on the state of the asset\u0026rsquo;s labels:\nvcn inspect \u0026lt;artifact\u0026gt; --label \u0026#39;demo\u0026#39; How labels are used in authentication # If the artifact was marked Trusted, and the label demo is assigned, then the status is TRUSTED. the label demo is missing, then the status is UNKNOWN. If the artifact was marked Untrusted/Unsupported, and the label demo is assigned, then the status is UNTRUSTED/UNSUPPORTED (respectively). the label demo is missing, then the status is UNKNOWN. "},{"id":9,"href":"/sbom-guide/vcn-usage/bom-authentication/","title":"Authenticating SBOMs","section":"Using vcn with Trustcenter","content":" Notarizing and Authenticating Software Bills of Materials (SBOMs) with Trustcenter # When a Software Bill of Materials (SBOM) is notarized by vcn for a container image, codebase, or other build artifact, that asset\u0026rsquo;s entire manifest of dependencies is also notarized and they are immutably associated with one another.\nThis process creates a chain of custody for the asset and its dependencies, allowing you to check the integrity of the asset, track which artifacts are deployed on your infrastructure, and ensure untrusted dependencies never reach production.\nResolving dependencies with vcn # You can use the vcn bom command to collect and display an artifact\u0026rsquo;s manifest of dependencies:\nvcn bom \u0026lt;artifact\u0026gt; Example: vcn bom Example command:\nvcn bom image://python:3.10-alpine Output:\n:\talpine-baselayout-data@3.2.0-r22 :\tmusl@1.2.3-r0 :\tbusybox@1.35.0-r17 :\talpine-baselayout@3.2.0-r22 :\talpine-keys@2.4-r1 :\tca-certificates-bundle@20220614-r0 :\tlibcrypto1.1@1.1.1q-r0 :\tlibssl1.1@1.1.1q-r0 :\tssl_client@1.35.0-r17 :\tzlib@1.2.12-r3 :\tapk-tools@2.12.9-r3 :\tscanelf@1.3.4-r0 :\tmusl-utils@1.2.3-r0 :\tlibc-utils@0.7.2-r3 :\tca-certificates@20220614-r0 :\ttzdata@2022a-r0 :\tncurses-terminfo-base@6.3_p20220521-r0 :\tncurses-libs@6.3_p20220521-r0 :\tlibbz2@1.0.8-r1 :\tsqlite-libs@3.38.5-r0 :\tlibffi@3.4.2-r1 :\tgdbm@1.23-r0 :\txz-libs@5.2.5-r1 :\texpat@2.4.8-r0 :\tlibintl@0.21-r2 :\tlibtirpc-conf@1.3.2-r1 :\tkrb5-conf@1.0-r2 :\tlibcom_err@1.46.5-r0 :\tkeyutils-libs@1.6.3-r1 :\tlibverto@0.3.2-r0 :\tkrb5-libs@1.19.3-r0 :\tlibtirpc@1.3.2-r1 :\tlibnsl@2.0.0-r0 :\tlibuuid@2.38-r1 :\treadline@8.1.2-r0 :\t.python-rundeps@20220907.224335 Notarizing an artifact\u0026rsquo;s bill of materials # You can make use of a bill of materials by notarizing it together with the artifact, using the vcn notarize command and the --bom flag:\nvcn notarize --bom \u0026lt;artifact\u0026gt; # Short form of command: vcn n --bom \u0026lt;artifact\u0026gt; Authenticating an artifact\u0026rsquo;s bill of materials # After an artifact has been notarized with its bill of materials, you can authenticate the artifact and its dependencies, using the vcn authenticate command and the --bom flag:\nvcn authenticate --bom \u0026lt;artifact\u0026gt; # Short form of command: vcn a --bom \u0026lt;artifact\u0026gt; "},{"id":10,"href":"/sbom-guide/vcn-usage/managing-dependencies/","title":"Working with Dependencies","section":"Using vcn with Trustcenter","content":" Looking up known dependencies with vcn # To\nvcn a --bom-what-includes (\u0026lt;scheme\u0026gt;://\u0026lt;name\u0026gt;@\u0026lt;version\u0026gt; | --hash \u0026lt;hash\u0026gt;) Container support with vcn # To\nvcn \u0026lt;command\u0026gt; \u0026lt;scheme\u0026gt;://\u0026lt;image_or_container\u0026gt; [command options] Cascade operations with vcn # To\nvcn notarize|untrust|unsupport [command options ...] --bom-cascade [--bom-force] "},{"id":11,"href":"/sbom-guide/vcn-usage/dependency-authentication/","title":"Authenticating Dependencies","section":"Using vcn with Trustcenter","content":" Authenticating Trusted Dependencies # If we attempt to authenticate a Docker image which has not yet been notarized with our signing key, we receive a warning that the asset hasn\u0026rsquo;t yet been notarized:\n❯ vcn authenticate --bom docker://python:3.9-alpine Warning: c9b90024bc4d49b1fa0ea4673b6eb1db1058cd1cba4b840d336bedf803a0afcf was not notarized When we then notarize the image, all of its dependencies are resolved, authenticated with Trustcenter, signed, and marked as Trusted:\n❯ vcn notarize --bom image://python:3.9-alpine Your assets will not be uploaded. They will be processed locally. Notarization in progress... artifact notarized Kind: image Name: python:3.9-alpine Hash: dca341b7a3fdbe1aa117f97f55321e60fe54a177d6f58ab3373ece796aca52ef Metadata: hashtype=\u0026#34;SHA256\u0026#34; image={ \u0026#34;Architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-07 23:29:27.440739972 +0000 UTC\u0026#34;, \u0026#34;DockerVersion\u0026#34;: \u0026#34;20.10.12\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;0721d3b351f08b8a337ace23d9e1f99cc9cab25b3459b95359b85054c631a1af\u0026#34;, . . . } platform=\u0026#34;linux\u0026#34; architecture=\u0026#34;amd64\u0026#34; SignerID: demo-signer Apikey revoked: no Status: TRUSTED Dependencies: busybox@1.35.0-r17 899f82d8925d0659b628ab403a44a433bcd97a06 TRUSTED musl@1.2.3-r0 682bb42e6503a00152397e3db87be4602d566ac4 TRUSTED alpine-keys@2.4-r1 1417c88edb049afbaaa0d5e94a15c3726fe68f31 TRUSTED alpine-baselayout@3.2.0-r22 97afe73342be73255da8d7e0929d7f73a625ce4d TRUSTED . . . keyutils-libs@1.6.3-r1 19eb523e1d62d8b90431763aa3073d30e3283fb2 TRUSTED libuuid@2.38-r1 68bd5e9b8fe99566387e2ad7b7a44c8cf0936673 TRUSTED readline@8.1.2-r0 f676007339535e21de79acffbe7ae743a1f7168c TRUSTED .python-rundeps@20220907.232918 2d6f839e7b5f86c10811f4574f044b3b3ad53417 TRUSTED If we then attempt to authenticate the image we just notarized, we can confirm that it is now marked as Trusted:\nvcn authenticate --bom image://python:3.9-alpine Kind: image Name: python:3.9-alpine Hash: dca341b7a3fdbe1aa117f97f55321e60fe54a177d6f58ab3373ece796aca52ef Metadata: architecture=\u0026#34;amd64\u0026#34; hashtype=\u0026#34;SHA256\u0026#34; image={ \u0026#34;Architecture\u0026#34;: \u0026#34;amd64\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-09-07 23:29:27.440739972 +0000 UTC\u0026#34;, \u0026#34;DockerVersion\u0026#34;: \u0026#34;20.10.12\u0026#34;, \u0026#34;Id\u0026#34;: \u0026#34;0721d3b351f08b8a337ace23d9e1f99cc9cab25b3459b95359b85054c631a1af\u0026#34;, . . . } platform=\u0026#34;linux\u0026#34; SignerID: demo-signer Apikey revoked: no Status: TRUSTED Dependencies: alpine-baselayout-data@3.2.0-r22 bf84212e37b7916942f03263f997c94e39494525 TRUSTED musl@1.2.3-r0 682bb42e6503a00152397e3db87be4602d566ac4 TRUSTED busybox@1.35.0-r17 899f82d8925d0659b628ab403a44a433bcd97a06 TRUSTED alpine-baselayout@3.2.0-r22 97afe73342be73255da8d7e0929d7f73a625ce4d TRUSTED . . . keyutils-libs@1.6.3-r1 19eb523e1d62d8b90431763aa3073d30e3283fb2 TRUSTED libuuid@2.38-r1 68bd5e9b8fe99566387e2ad7b7a44c8cf0936673 TRUSTED readline@8.1.2-r0 f676007339535e21de79acffbe7ae743a1f7168c TRUSTED .python-rundeps@20220907.232918 2d6f839e7b5f86c10811f4574f044b3b3ad53417 TRUSTED Let\u0026rsquo;s say there is a hypothetical vulnerability discovered in the package keyutils-libs@1.6.3-r1, and we want to ensure we don\u0026rsquo;t run any containers based on images containing this dependency.\nWe can take the untrusted dependency\u0026rsquo;s hash and mark it as untrusted:\n❯ vcn untrust --hash 19eb523e1d62d8b90431763aa3073d30e3283fb2 Your assets will not be uploaded. They will be processed locally. Notarization in progress... artifact notarized Name: keyutils-libs Hash: 19eb523e1d62d8b90431763aa3073d30e3283fb2 Metadata: hashtype=\u0026#34;SHA1\u0026#34; license=\u0026#34;GPL-2.0-or-later LGPL-2.0-or-later\u0026#34; version=\u0026#34;1.6.3-r1\u0026#34; SignerID: demo-signer Apikey revoked: no Status: UNTRUSTED Now, when we attempt to notarize any assets that contain our known-vulnerable dependency, we will see that the notarization fails:\n❯ vcn notarize --bom image://python:3.10-alpine Dependency keyutils-libs@1.6.3-r1 trust level is UNTRUSTED Error: some dependencies have insufficient trust level so artifact cannot be notarized. You can override it with --bom-force option Because the keyutils-libs@1.6.3-r1 dependency has already been marked as untrusted with our current signing key, any future attempts to notarize an asset containing that dependency will fail.\n"},{"id":12,"href":"/sbom-guide/vcn-usage/bom-interoperability/","title":"Working with Other Tools","section":"Using vcn with Trustcenter","content":" Exchanging Data with Other Tools # Import from spfx and cyclonedx # TODO.\nExport to spfx or cyclonedx # TODO.\n"},{"id":13,"href":"/sbom-guide/reference/glossary/notarize/","title":"Notarize","section":"Glossary","content":" Notarize (definition) # "},{"id":14,"href":"/sbom-guide/examples/vulnerability-search/","title":"Searching for Vulnerabilities","section":"Examples \u0026 Use Cases","content":" Searching for Vulnerabilities with Trustcenter # "}]